<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>aimet_torch.quantsim &mdash; AI Model Efficiency Toolkit Documentation: ver tf-torch-cpu_1.25.0</title><link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/style.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/language_data.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "tex2jax_ignore|mathjax_ignore|document", "processClass": "tex2jax_process|mathjax_process|math|output_area"}})</script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../user_guide/index.html" class="icon icon-home">
            AI Model Efficiency Toolkit
              <img src="../../_static/brain_logo.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                tf-torch-cpu_1.25.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../user_guide/model_quantization.html">Quantization User Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../user_guide/model_quantization.html#use-cases">Use Cases</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../user_guide/model_quantization.html#aimet-quantization-features">AIMET Quantization Features</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../user_guide/model_quantization.html#aimet-quantization-workflow">AIMET Quantization Workflow</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../user_guide/model_quantization.html#debugging-guidelines">Debugging Guidelines</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../user_guide/model_compression.html">Compression User Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../user_guide/model_compression.html#overview">Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../user_guide/model_compression.html#use-case">Use Case</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../user_guide/model_compression.html#compression-ratio-selection">Compression ratio selection</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../user_guide/visualization_compression.html">Visualization</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../user_guide/visualization_compression.html#overview">Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../user_guide/visualization_compression.html#design">Design</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../user_guide/visualization_compression.html#compression">Compression</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../user_guide/visualization_compression.html#starting-a-bokeh-server-session">Starting a Bokeh Server Session:</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../user_guide/visualization_compression.html#how-to-use-the-tool">How to use the tool</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../user_guide/model_compression.html#model-compression">Model Compression</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../user_guide/weight_svd.html">Weight SVD</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../user_guide/spatial_svd.html">Spatial SVD</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../user_guide/channel_pruning.html">Channel Pruning</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../user_guide/channel_pruning.html#overall-procedure">Overall Procedure</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../user_guide/channel_pruning.html#channel-selection">Channel Selection</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../user_guide/channel_pruning.html#winnowing">Winnowing</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../user_guide/channel_pruning.html#weight-reconstruction">Weight Reconstruction</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../user_guide/model_compression.html#optional-techniques-to-get-better-compression-results">Optional techniques to get better compression results</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../user_guide/model_compression.html#rank-rounding">Rank Rounding</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../user_guide/model_compression.html#per-layer-fine-tuning">Per-layer Fine-tuning</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../user_guide/model_compression.html#faqs">FAQs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../user_guide/model_compression.html#references">References</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../api_docs/index.html">API Documentation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../api_docs/torch.html">AIMET APIs for PyTorch</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../api_docs/torch_quantization.html">PyTorch Model Quantization API</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api_docs/torch_compress.html">PyTorch Model Compression API</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/torch_compress.html#introduction">Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/torch_compress.html#top-level-api-for-compression">Top-level API for Compression</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/torch_compress.html#greedy-selection-parameters">Greedy Selection Parameters</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/torch_compress.html#tar-selection-parameters">TAR Selection Parameters</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/torch_compress.html#spatial-svd-configuration">Spatial SVD Configuration</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/torch_compress.html#weight-svd-configuration">Weight SVD Configuration</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/torch_compress.html#channel-pruning-configuration">Channel Pruning Configuration</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/torch_compress.html#configuration-definitions">Configuration Definitions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/torch_compress.html#code-examples">Code Examples</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../api_docs/torch_visualization_compression.html">PyTorch Model Visualization API for Compression</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/torch_visualization_compression.html#top-level-api-compression">Top-level API Compression</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/torch_visualization_compression.html#code-examples">Code Examples</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../api_docs/torch_visualization_quantization.html">PyTorch Model Visualization API for Quantization</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/torch_visualization_quantization.html#top-level-api-quantization">Top-level API Quantization</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/torch_visualization_quantization.html#code-examples">Code Examples</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../api_docs/tensorflow.html">AIMET APIs for TensorFlow</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../api_docs/tensorflow_model_guidelines.html">TensorFlow Model Guidelines</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api_docs/tensorflow_quantization.html">TensorFlow Model Quantization API</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api_docs/tensorflow_compress.html">TensorFlow Model Compression API</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/tensorflow_compress.html#introduction">Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/tensorflow_compress.html#top-level-api-for-compression">Top-level API for Compression</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/tensorflow_compress.html#greedy-selection-parameters">Greedy Selection Parameters</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/tensorflow_compress.html#spatial-svd-configuration">Spatial SVD Configuration</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/tensorflow_compress.html#channel-pruning-configuration">Channel Pruning Configuration</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/tensorflow_compress.html#configuration-definitions">Configuration Definitions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/tensorflow_compress.html#code-examples">Code Examples</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/tensorflow_compress.html#weight-svd-top-level-api">Weight SVD Top-level API</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/tensorflow_compress.html#code-examples-for-weight-svd">Code Examples for Weight SVD</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../api_docs/tensorflow_visualization_quantization.html">TensorFlow Model Visualization API for Quantization</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/tensorflow_visualization_quantization.html#top-level-api-for-visualization-of-weight-tensors">Top-level API for Visualization of Weight tensors</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/tensorflow_visualization_quantization.html#code-examples-for-visualization-of-weight-tensors">Code Examples for Visualization of Weight tensors</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../api_docs/convert_tf_sess_to_keras.html">Using AIMET Tensorflow APIs with Keras Models</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/convert_tf_sess_to_keras.html#introduction">Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/convert_tf_sess_to_keras.html#apis">APIs</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/convert_tf_sess_to_keras.html#code-example">Code Example</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api_docs/convert_tf_sess_to_keras.html#utility-functions">Utility Functions</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../api_docs/keras.html">AIMET APIs for Keras</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../api_docs/keras_quantization.html">Keras Model Quantization API</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../api_docs/index.html#indices-and-tables">Indices and tables</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../user_guide/examples.html">Examples Documentation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../user_guide/examples.html#browse-the-notebooks">Browse the notebooks</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../user_guide/examples.html#running-the-notebooks">Running the notebooks</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../user_guide/examples.html#install-jupyter">Install Jupyter</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../user_guide/examples.html#download-the-example-notebooks-and-related-code">Download the Example notebooks and related code</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../user_guide/examples.html#run-the-notebooks">Run the notebooks</a></li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../user_guide/index.html">AI Model Efficiency Toolkit</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../user_guide/index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">aimet_torch.quantsim</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for aimet_torch.quantsim</h1><div class="highlight"><pre>
<span></span><span class="c1"># /usr/bin/env python3.8</span>
<span class="c1"># -*- mode: python -*-</span>
<span class="c1"># =============================================================================</span>
<span class="c1">#  @@-COPYRIGHT-START-@@</span>
<span class="c1">#</span>
<span class="c1">#  Copyright (c) 2019-2023, Qualcomm Innovation Center, Inc. All rights reserved.</span>
<span class="c1">#</span>
<span class="c1">#  Redistribution and use in source and binary forms, with or without</span>
<span class="c1">#  modification, are permitted provided that the following conditions are met:</span>
<span class="c1">#</span>
<span class="c1">#  1. Redistributions of source code must retain the above copyright notice,</span>
<span class="c1">#     this list of conditions and the following disclaimer.</span>
<span class="c1">#</span>
<span class="c1">#  2. Redistributions in binary form must reproduce the above copyright notice,</span>
<span class="c1">#     this list of conditions and the following disclaimer in the documentation</span>
<span class="c1">#     and/or other materials provided with the distribution.</span>
<span class="c1">#</span>
<span class="c1">#  3. Neither the name of the copyright holder nor the names of its contributors</span>
<span class="c1">#     may be used to endorse or promote products derived from this software</span>
<span class="c1">#     without specific prior written permission.</span>
<span class="c1">#</span>
<span class="c1">#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;</span>
<span class="c1">#  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</span>
<span class="c1">#  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</span>
<span class="c1">#  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE</span>
<span class="c1">#  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR</span>
<span class="c1">#  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</span>
<span class="c1">#  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</span>
<span class="c1">#  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</span>
<span class="c1">#  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</span>
<span class="c1">#  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE</span>
<span class="c1">#  POSSIBILITY OF SUCH DAMAGE.</span>
<span class="c1">#</span>
<span class="c1">#  SPDX-License-Identifier: BSD-3-Clause</span>
<span class="c1">#</span>
<span class="c1">#  @@-COPYRIGHT-END-@@</span>
<span class="c1"># =============================================================================</span>

<span class="sd">&quot;&quot;&quot; Implementation for simulating models running on Quantized hardware &quot;&quot;&quot;</span>
<span class="c1"># pylint: disable=too-many-lines</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">io</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Set</span><span class="p">,</span> <span class="n">Optional</span>
<span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Iterable</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">import</span> <span class="nn">onnx</span>

<span class="kn">import</span> <span class="nn">aimet_common</span>
<span class="kn">import</span> <span class="nn">aimet_common.libpymo</span> <span class="k">as</span> <span class="nn">libpymo</span>
<span class="kn">from</span> <span class="nn">aimet_common.utils</span> <span class="kn">import</span> <span class="n">AimetLogger</span><span class="p">,</span> <span class="n">save_json_yaml</span>
<span class="kn">from</span> <span class="nn">aimet_common.defs</span> <span class="kn">import</span> <span class="n">QuantScheme</span><span class="p">,</span> <span class="n">QuantizationDataType</span><span class="p">,</span> <span class="n">SupportedKernelsAction</span><span class="p">,</span> <span class="n">QuantDtypeBwInfo</span>
<span class="kn">from</span> <span class="nn">aimet_common.quantsim</span> <span class="kn">import</span> <span class="n">encoding_version</span><span class="p">,</span> <span class="n">validate_quantsim_inputs</span><span class="p">,</span> <span class="n">extract_global_quantizer_args</span>
<span class="kn">from</span> <span class="nn">aimet_common.quant_utils</span> <span class="kn">import</span> <span class="n">get_conv_accum_bounds</span>

<span class="kn">from</span> <span class="nn">aimet_torch.quantsim_config.quantsim_config</span> <span class="kn">import</span> <span class="n">QuantSimConfigurator</span>
<span class="kn">from</span> <span class="nn">aimet_torch.qc_quantize_op</span> <span class="kn">import</span> <span class="n">QcQuantizeStandAloneBase</span><span class="p">,</span> <span class="n">QcQuantizeWrapper</span><span class="p">,</span> <span class="n">QcQuantizeOpMode</span><span class="p">,</span> \
    <span class="n">StaticGridQuantWrapper</span><span class="p">,</span> <span class="n">LearnedGridQuantWrapper</span><span class="p">,</span> <span class="n">QUANTIZER_TYPE_INPUT</span><span class="p">,</span> <span class="n">QUANTIZER_TYPE_OUTPUT</span>
<span class="kn">from</span> <span class="nn">aimet_torch.tensor_quantizer</span> <span class="kn">import</span> <span class="n">StaticGridTensorQuantizer</span><span class="p">,</span> <span class="n">LearnedGridTensorQuantizer</span>
<span class="kn">from</span> <span class="nn">aimet_torch</span> <span class="kn">import</span> <span class="n">torchscript_utils</span><span class="p">,</span> <span class="n">utils</span><span class="p">,</span> <span class="n">transformer_utils</span>
<span class="kn">from</span> <span class="nn">aimet_torch.onnx_utils</span> <span class="kn">import</span> <span class="n">OnnxSaver</span><span class="p">,</span> <span class="n">OnnxExportApiArgs</span><span class="p">,</span> <span class="n">CustomMarker</span>
<span class="kn">from</span> <span class="nn">aimet_torch.meta.connectedgraph</span> <span class="kn">import</span> <span class="n">ConnectedGraph</span>
<span class="kn">from</span> <span class="nn">aimet_torch.qc_quantize_recurrent</span> <span class="kn">import</span> <span class="n">QcQuantizeRecurrent</span>


<span class="n">logger</span> <span class="o">=</span> <span class="n">AimetLogger</span><span class="o">.</span><span class="n">get_area_logger</span><span class="p">(</span><span class="n">AimetLogger</span><span class="o">.</span><span class="n">LogAreas</span><span class="o">.</span><span class="n">Quant</span><span class="p">)</span>

<span class="c1"># Types of modules which cannot be quantized</span>
<span class="n">unquantizable_modules</span> <span class="o">=</span> <span class="p">(</span><span class="n">QcQuantizeWrapper</span><span class="p">,</span> <span class="n">QcQuantizeStandAloneBase</span><span class="p">,</span> <span class="n">QcQuantizeRecurrent</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Identity</span><span class="p">)</span>

<span class="c1"># If a torch module type is in this dictionary, call the corresponding quantized module constructor instead of wrapping</span>
<span class="c1"># it with QcQuantizeWrapper.</span>
<span class="n">qc_quantize_modules_dict</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">RNN</span><span class="p">:</span> <span class="n">QcQuantizeRecurrent</span><span class="p">,</span>
    <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">LSTM</span><span class="p">:</span> <span class="n">QcQuantizeRecurrent</span><span class="p">,</span>
    <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">GRU</span><span class="p">:</span> <span class="n">QcQuantizeRecurrent</span>
<span class="p">}</span>

<span class="c1"># Length of the string &#39;._module_to_wrap&#39;</span>
<span class="n">MODULE_TO_WRAP_STRING_REVERSE_INDEX</span> <span class="o">=</span> <span class="o">-</span><span class="mi">16</span>

<span class="n">MAP_PYMO_TO_ROUND_MODE</span> <span class="o">=</span> <span class="p">{</span><span class="n">libpymo</span><span class="o">.</span><span class="n">RoundingMode</span><span class="o">.</span><span class="n">ROUND_NEAREST</span><span class="p">:</span> <span class="s1">&#39;nearest&#39;</span><span class="p">,</span>
                          <span class="n">libpymo</span><span class="o">.</span><span class="n">RoundingMode</span><span class="o">.</span><span class="n">ROUND_STOCHASTIC</span><span class="p">:</span> <span class="s1">&#39;stochastic&#39;</span><span class="p">}</span>

<span class="n">SUPPORTED_KERNELS_ACTION</span> <span class="o">=</span> <span class="n">SupportedKernelsAction</span><span class="o">.</span><span class="n">warn_on_error</span>

<span class="n">DROPOUT_TYPES</span> <span class="o">=</span> <span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Dropout</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Dropout2d</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Dropout3d</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_get_encoding_by_quantizer</span><span class="p">(</span><span class="n">quantizer</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">StaticGridTensorQuantizer</span><span class="p">,</span>
                                                <span class="n">LearnedGridTensorQuantizer</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">libpymo</span><span class="o">.</span><span class="n">TfEncoding</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">libpymo</span><span class="o">.</span><span class="n">TfEncoding</span><span class="p">]]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Retrieve encoding object by quantizer type (StaticGridTensorQuantizer or LearnedGridTensorQuantizer)</span>
<span class="sd">    In particular, LearnedGridTensorQuantizer should use get_effective_encoding to achieve true encoding</span>
<span class="sd">    :param quantizer: TensorQuantizer (StaticGridTensorQuantizer or LearnedGridTensorQuantizer)</span>
<span class="sd">    :return: TfEncoding or list of TfEncoding. None if quantizer is not enabled</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">quantizer</span><span class="p">,</span> <span class="n">LearnedGridTensorQuantizer</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">quantizer</span><span class="o">.</span><span class="n">get_effective_encoding</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">quantizer</span><span class="o">.</span><span class="n">encoding</span>


<div class="viewcode-block" id="QuantParams"><a class="viewcode-back" href="../../api_docs/torch_bias_correction.html#aimet_torch.quantsim.QuantParams">[docs]</a><span class="k">class</span> <span class="nc">QuantParams</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Data type to hold quantization related params.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">weight_bw</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
                 <span class="n">act_bw</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
                 <span class="n">round_mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;nearest&#39;</span><span class="p">,</span>
                 <span class="n">quant_scheme</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">QuantScheme</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">QuantScheme</span><span class="o">.</span><span class="n">post_training_tf_enhanced</span><span class="p">,</span>
                 <span class="n">config_file</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor</span>

<span class="sd">        :param weight_bw: Weight bitwidth (4-31) to use for quantizing layer weights. Default = 8</span>
<span class="sd">        :param act_bw: Activation bitwidth(4-31) to use for quantizing layer activations. Default = 8</span>
<span class="sd">        :param round_mode: Rounding mode. Supported options are &#39;nearest&#39; or &#39;stochastic&#39;</span>
<span class="sd">        :param quant_scheme: Quantization scheme. Supported options are &#39;tf_enhanced&#39; or &#39;tf&#39; or using Quant Scheme Enum</span>
<span class="sd">                             QuantScheme.post_training_tf or QuantScheme.post_training_tf_enhanced</span>
<span class="sd">        :param config_file: Path to Configuration file for model quantizers</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">weight_bw</span> <span class="o">=</span> <span class="n">weight_bw</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">act_bw</span> <span class="o">=</span> <span class="n">act_bw</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">round_mode</span> <span class="o">=</span> <span class="n">round_mode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">quant_scheme</span> <span class="o">=</span> <span class="n">quant_scheme</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">config_file</span> <span class="o">=</span> <span class="n">config_file</span></div>


<div class="viewcode-block" id="QuantizationSimModel"><a class="viewcode-back" href="../../api_docs/torch_quantsim.html#aimet_torch.quantsim.QuantizationSimModel">[docs]</a><span class="k">class</span> <span class="nc">QuantizationSimModel</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Implements mechanism to add quantization simulations ops to a model. This allows for off-target simulation of</span>
<span class="sd">    inference accuracy. Also allows the model to be fine-tuned to counter the effects of quantization.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># pylint: disable=too-many-arguments, too-many-instance-attributes</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">,</span> <span class="n">dummy_input</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">],</span>
                 <span class="n">quant_scheme</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">QuantScheme</span><span class="p">]</span> <span class="o">=</span> <span class="n">QuantScheme</span><span class="o">.</span><span class="n">post_training_tf_enhanced</span><span class="p">,</span>
                 <span class="n">rounding_mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;nearest&#39;</span><span class="p">,</span> <span class="n">default_output_bw</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span> <span class="n">default_param_bw</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
                 <span class="n">in_place</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">config_file</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">default_data_type</span><span class="p">:</span> <span class="n">QuantizationDataType</span> <span class="o">=</span> <span class="n">QuantizationDataType</span><span class="o">.</span><span class="n">int</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor</span>

<span class="sd">        :param model: Model to add simulation ops to</span>
<span class="sd">        :param dummy_input: Dummy input to the model. Used to parse model graph. If the model has more than one input,</span>
<span class="sd">                            pass a tuple. User is expected to place the tensors on the appropriate device.</span>
<span class="sd">        :param quant_scheme: Quantization scheme. The Quantization scheme is used to compute the Quantization encodings.</span>
<span class="sd">                             There are multiple schemes available. Please refer the QuantScheme enum definition.</span>
<span class="sd">        :param rounding_mode: Rounding mode. Supported options are &#39;nearest&#39; or &#39;stochastic&#39;</span>
<span class="sd">        :param default_output_bw: Default bitwidth (4-31) to use for quantizing all layer inputs and outputs</span>
<span class="sd">        :param default_param_bw: Default bitwidth (4-31) to use for quantizing all layer parameters</span>
<span class="sd">        :param in_place: If True, then the given &#39;model&#39; is modified in-place to add quant-sim nodes.</span>
<span class="sd">                Only suggested use of this option is when the user wants to avoid creating a copy of the model</span>
<span class="sd">        :param config_file: Path to Configuration file for model quantizers</span>
<span class="sd">        :param default_data_type: Default data type to use for quantizing all layer inputs, outputs and parameters.</span>
<span class="sd">                                 Possible options are QuantizationDataType.int and QuantizationDataType.float.</span>
<span class="sd">                                 Note that the mode default_data_type=QuantizationDataType.float is only supported with</span>
<span class="sd">                                 default_output_bw=16 and default_param_bw=16</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Perform sanity checks on inputs</span>
        <span class="n">validate_quantsim_inputs</span><span class="p">(</span><span class="n">quant_scheme</span><span class="p">,</span> <span class="n">rounding_mode</span><span class="p">,</span> <span class="n">default_output_bw</span><span class="p">,</span> <span class="n">default_param_bw</span><span class="p">,</span>
                                 <span class="n">default_data_type</span><span class="p">)</span>

        <span class="c1"># save some parameters</span>
        <span class="k">if</span> <span class="n">in_place</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">model</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">connected_graph</span> <span class="o">=</span> <span class="n">ConnectedGraph</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="n">dummy_input</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">jit</span><span class="o">.</span><span class="n">TracingCheckError</span><span class="p">,</span> <span class="ne">AssertionError</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">connected_graph</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">quant_scheme</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">quant_scheme</span> <span class="o">==</span> <span class="s1">&#39;tf&#39;</span><span class="p">:</span>
                <span class="n">quant_scheme</span> <span class="o">=</span> <span class="n">QuantScheme</span><span class="o">.</span><span class="n">post_training_tf</span>
            <span class="k">elif</span> <span class="n">quant_scheme</span> <span class="o">==</span> <span class="s1">&#39;tf_enhanced&#39;</span><span class="p">:</span>
                <span class="n">quant_scheme</span> <span class="o">=</span> <span class="n">QuantScheme</span><span class="o">.</span><span class="n">post_training_tf_enhanced</span>
            <span class="k">elif</span> <span class="n">quant_scheme</span> <span class="o">==</span> <span class="s1">&#39;percentile&#39;</span><span class="p">:</span>
                <span class="n">quant_scheme</span> <span class="o">=</span> <span class="n">QuantScheme</span><span class="o">.</span><span class="n">post_training_percentile</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_quant_scheme</span> <span class="o">=</span> <span class="n">quant_scheme</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rounding_mode</span> <span class="o">=</span> <span class="n">rounding_mode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_default_output_bw</span> <span class="o">=</span> <span class="n">default_output_bw</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_default_param_bw</span> <span class="o">=</span> <span class="n">default_param_bw</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_conditional</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_module_marker_map</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_percentile_value</span> <span class="o">=</span> <span class="mi">100</span> <span class="c1"># default percentile value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_excluded_layer_names</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Add quantization layers</span>
        <span class="n">num_inout_tensors</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">find_num_inout_tensors_per_module</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="n">dummy_input</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_add_quantization_wrappers</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="n">num_inout_tensors</span><span class="p">,</span> <span class="n">default_data_type</span><span class="p">)</span>

        <span class="c1"># Disable bias quantization</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exclude_param_from_quantization</span><span class="p">(</span><span class="s2">&quot;bias&quot;</span><span class="p">)</span>

        <span class="c1"># override specific quantizers to tf mode in transformer model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_override_quant_config_for_transformer_layers</span><span class="p">()</span>

        <span class="n">quantsim_configurator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">configure_quantization_ops</span><span class="p">(</span><span class="n">config_file</span><span class="p">,</span> <span class="n">default_output_bw</span><span class="p">,</span> <span class="n">default_param_bw</span><span class="p">,</span>
                                                                <span class="n">default_data_type</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">quant_args</span> <span class="o">=</span> <span class="n">extract_global_quantizer_args</span><span class="p">(</span><span class="n">quant_scheme</span><span class="p">,</span> <span class="n">quantsim_configurator</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_supported_kernels</span> <span class="o">=</span> <span class="n">quantsim_configurator</span><span class="o">.</span><span class="n">get_supported_kernels</span><span class="p">()</span>
        <span class="c1"># pylint: disable=protected-access</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hw_version</span> <span class="o">=</span> <span class="n">quantsim_configurator</span><span class="o">.</span><span class="n">_get_hw_version</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_validate_supported_kernels_for_quantizers</span><span class="p">(</span><span class="n">SUPPORTED_KERNELS_ACTION</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_supported_kernels</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return _supported_kernels parsed from the config file</span>
<span class="sd">        :return: Dictionary containing supported_kernels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_supported_kernels</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pretty-printed output indicating where in the model, quantizers have been activated</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">pp_quantizer</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">quantizer</span><span class="p">,</span> <span class="n">prefix_string</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">quantizer</span><span class="o">.</span><span class="n">enabled</span><span class="p">:</span>
                <span class="n">stream</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;  </span><span class="si">{</span><span class="n">prefix_string</span><span class="si">}</span><span class="s1">: bw=</span><span class="si">{</span><span class="n">quantizer</span><span class="o">.</span><span class="n">bitwidth</span><span class="si">}</span><span class="s1">, &#39;</span>
                             <span class="sa">f</span><span class="s1">&#39;encoding-present=</span><span class="si">{</span><span class="nb">bool</span><span class="p">(</span><span class="n">quantizer</span><span class="o">.</span><span class="n">encoding</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">quantizer</span><span class="o">.</span><span class="n">encoding</span><span class="p">:</span>
                    <span class="n">stream</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;    </span><span class="si">{</span><span class="n">quantizer</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">stream</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;  </span><span class="si">{</span><span class="n">prefix_string</span><span class="si">}</span><span class="s1">: Not quantized</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

            <span class="n">stream</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;  -------</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="n">stream</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">StringIO</span><span class="p">(</span><span class="n">newline</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">stream</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;-------------------------</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">stream</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Quantized Model Report</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">stream</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;-------------------------</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">wrappers</span> <span class="o">=</span> <span class="p">[(</span><span class="n">name</span><span class="p">,</span> <span class="n">module</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">module</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">named_modules</span><span class="p">()</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">QcQuantizeWrapper</span><span class="p">)]</span>

        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">wrapper</span> <span class="ow">in</span> <span class="n">wrappers</span><span class="p">:</span>
            <span class="n">stream</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;----------------------------------------------------------</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">stream</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;Layer: </span><span class="si">{}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>

            <span class="c1"># Inputs</span>
            <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">quantizer</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">wrapper</span><span class="o">.</span><span class="n">input_quantizers</span><span class="p">):</span>
                <span class="n">pp_quantizer</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">quantizer</span><span class="p">,</span> <span class="n">prefix_string</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;Input[</span><span class="si">{</span><span class="n">index</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">)</span>

            <span class="c1"># Params</span>
            <span class="k">for</span> <span class="n">param_name</span><span class="p">,</span> <span class="n">quantizer</span> <span class="ow">in</span> <span class="n">wrapper</span><span class="o">.</span><span class="n">param_quantizers</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">pp_quantizer</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">quantizer</span><span class="p">,</span> <span class="n">prefix_string</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;Param[</span><span class="si">{</span><span class="n">param_name</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">)</span>

            <span class="c1"># Outputs</span>
            <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">quantizer</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">wrapper</span><span class="o">.</span><span class="n">output_quantizers</span><span class="p">):</span>
                <span class="n">pp_quantizer</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">quantizer</span><span class="p">,</span> <span class="n">prefix_string</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;Output[</span><span class="si">{</span><span class="n">index</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">stream</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span>

<div class="viewcode-block" id="QuantizationSimModel.compute_encodings"><a class="viewcode-back" href="../../api_docs/torch_quantsim.html#aimet_torch.quantsim.QuantizationSimModel.compute_encodings">[docs]</a>    <span class="k">def</span> <span class="nf">compute_encodings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">forward_pass_callback</span><span class="p">,</span> <span class="n">forward_pass_callback_args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes encodings for all quantization sim nodes in the model. It is also used to find initial encodings for</span>
<span class="sd">        Range Learning</span>

<span class="sd">        :param forward_pass_callback: A callback function that simply runs forward passes on the model. This callback</span>
<span class="sd">            function should use representative data for the forward pass, so the calculated encodings work for all</span>
<span class="sd">            data samples. This callback internally chooses the number of data samples it wants to use for calculating</span>
<span class="sd">            encodings.</span>
<span class="sd">        :param forward_pass_callback_args: These argument(s) are passed to the forward_pass_callback as-is. Up to</span>
<span class="sd">            the user to determine the type of this parameter. E.g. could be simply an integer representing the number</span>
<span class="sd">            of data samples to use. Or could be a tuple of parameters or an object representing something more complex.</span>
<span class="sd">            If set to None, forward_pass_callback will be invoked with no parameters.</span>
<span class="sd">        :return: None</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">quantized_layers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_qc_quantized_layers</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">layer</span> <span class="ow">in</span> <span class="n">quantized_layers</span><span class="p">:</span>
            <span class="c1"># Clear stats and encodings if they are present</span>
            <span class="n">layer</span><span class="o">.</span><span class="n">reset_encodings</span><span class="p">()</span>

            <span class="c1"># And set the mode to analysis</span>
            <span class="n">layer</span><span class="o">.</span><span class="n">set_mode</span><span class="p">(</span><span class="n">QcQuantizeOpMode</span><span class="o">.</span><span class="n">ANALYSIS</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">layer</span> <span class="ow">in</span> <span class="n">quantized_layers</span><span class="p">:</span>
            <span class="c1"># call only when quant scheme is percentile</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quant_scheme</span> <span class="o">==</span> <span class="n">QuantScheme</span><span class="o">.</span><span class="n">post_training_percentile</span><span class="p">:</span>
                <span class="n">layer</span><span class="o">.</span><span class="n">set_percentile_value</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_percentile_value</span><span class="p">)</span>

        <span class="c1"># Run forward iterations so we can collect statistics to compute the appropriate encodings</span>
        <span class="k">with</span> <span class="n">utils</span><span class="o">.</span><span class="n">in_eval_mode</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">),</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
            <span class="n">_</span> <span class="o">=</span> <span class="n">forward_pass_callback</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="n">forward_pass_callback_args</span><span class="p">)</span>

        <span class="c1"># Get the computed per-layer encodings and log them</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">layer</span> <span class="ow">in</span> <span class="n">quantized_layers</span><span class="p">:</span>
            <span class="n">layer</span><span class="o">.</span><span class="n">compute_encoding</span><span class="p">()</span>

            <span class="c1"># Before we return we set the mode to active - meaning ready for quantize/de-quantize</span>
            <span class="c1"># for layers with valid_encoding, otherwise we set to pass through</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="n">QcQuantizeRecurrent</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_mode_for_recurrent_module</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># By default we want to set the Quantization wrappers to ACTIVE mode</span>
                <span class="n">layer</span><span class="o">.</span><span class="n">set_mode</span><span class="p">(</span><span class="n">QcQuantizeOpMode</span><span class="o">.</span><span class="n">ACTIVE</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">replace_wrappers_for_quantize_dequantize</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_clamp_transformer_attention_mask_encoding</span><span class="p">()</span></div>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">set_mode_for_recurrent_module</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">layer</span><span class="p">:</span> <span class="n">QcQuantizeRecurrent</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets Recurrent module to active or pass through mode based on quantizer state</span>

<span class="sd">        :param layer:  Qc Quantizer layer for recurrent module</span>
<span class="sd">        :param name:  layer name</span>
<span class="sd">        :return: True if the encoding is invalid</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">quantizer_name</span><span class="p">,</span> <span class="n">output_quantizer</span> <span class="ow">in</span> <span class="n">layer</span><span class="o">.</span><span class="n">output_quantizers</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">output_quantizer</span><span class="o">.</span><span class="n">enabled</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">output_quantizer</span><span class="o">.</span><span class="n">encoding</span><span class="p">:</span>
                    <span class="n">encoding</span> <span class="o">=</span> <span class="n">output_quantizer</span><span class="o">.</span><span class="n">encoding</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Encoding for </span><span class="si">%s</span><span class="s2">-</span><span class="si">%s</span><span class="s2">: min=</span><span class="si">%f</span><span class="s2">, max=</span><span class="si">%f</span><span class="s2">, offset=</span><span class="si">%f</span><span class="s2">. delta=</span><span class="si">%f</span><span class="s2">, bw=</span><span class="si">%f</span><span class="s2">&quot;</span><span class="p">,</span>
                                 <span class="n">name</span><span class="p">,</span> <span class="n">quantizer_name</span><span class="p">,</span> <span class="n">encoding</span><span class="o">.</span><span class="n">min</span><span class="p">,</span> <span class="n">encoding</span><span class="o">.</span><span class="n">max</span><span class="p">,</span>
                                 <span class="n">encoding</span><span class="o">.</span><span class="n">delta</span><span class="p">,</span> <span class="n">encoding</span><span class="o">.</span><span class="n">offset</span><span class="p">,</span> <span class="n">encoding</span><span class="o">.</span><span class="n">bw</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">quantizer_name</span><span class="p">,</span> <span class="n">input_quantizer</span> <span class="ow">in</span> <span class="n">layer</span><span class="o">.</span><span class="n">input_quantizers</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">input_quantizer</span><span class="o">.</span><span class="n">enabled</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">input_quantizer</span><span class="o">.</span><span class="n">encoding</span><span class="p">:</span>
                    <span class="n">encoding</span> <span class="o">=</span> <span class="n">input_quantizer</span><span class="o">.</span><span class="n">encoding</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Encoding for </span><span class="si">%s</span><span class="s2">-</span><span class="si">%s</span><span class="s2">: min=</span><span class="si">%f</span><span class="s2">, max=</span><span class="si">%f</span><span class="s2">, offset=</span><span class="si">%f</span><span class="s2">. delta=</span><span class="si">%f</span><span class="s2">, bw=</span><span class="si">%f</span><span class="s2">&quot;</span><span class="p">,</span>
                                 <span class="n">name</span><span class="p">,</span> <span class="n">quantizer_name</span><span class="p">,</span> <span class="n">encoding</span><span class="o">.</span><span class="n">min</span><span class="p">,</span> <span class="n">encoding</span><span class="o">.</span><span class="n">max</span><span class="p">,</span>
                                 <span class="n">encoding</span><span class="o">.</span><span class="n">delta</span><span class="p">,</span> <span class="n">encoding</span><span class="o">.</span><span class="n">offset</span><span class="p">,</span> <span class="n">encoding</span><span class="o">.</span><span class="n">bw</span><span class="p">)</span>

        <span class="n">layer</span><span class="o">.</span><span class="n">set_mode</span><span class="p">(</span><span class="n">QcQuantizeOpMode</span><span class="o">.</span><span class="n">ACTIVE</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_percentile_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">percentile_value</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the percentile value to be used while computing encodings</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">percentile_value</span> <span class="o">&lt;</span> <span class="mi">90</span> <span class="ow">or</span> <span class="n">percentile_value</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Percentile value must be in range [90, 100]&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_percentile_value</span> <span class="o">=</span> <span class="n">percentile_value</span>

<div class="viewcode-block" id="QuantizationSimModel.export"><a class="viewcode-back" href="../../api_docs/torch_quantsim.html#aimet_torch.quantsim.QuantizationSimModel.export">[docs]</a>    <span class="k">def</span> <span class="nf">export</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">filename_prefix</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">dummy_input</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">],</span>
               <span class="n">onnx_export_args</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">OnnxExportApiArgs</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="n">OnnxExportApiArgs</span><span class="p">(),</span>
               <span class="n">propagate_encodings</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method exports out the quant-sim model so it is ready to be run on-target.</span>

<span class="sd">        Specifically, the following are saved</span>

<span class="sd">        1. The sim-model is exported to a regular PyTorch model without any simulation ops</span>
<span class="sd">        2. The quantization encodings are exported to a separate JSON-formatted file that can</span>
<span class="sd">           then be imported by the on-target runtime (if desired)</span>
<span class="sd">        3. Optionally, An equivalent model in ONNX format is exported. In addition, nodes in the ONNX model are named</span>
<span class="sd">           the same as the corresponding PyTorch module names. This helps with matching ONNX node to their quant</span>
<span class="sd">           encoding from #2.</span>

<span class="sd">        :param path: path where to store model pth and encodings</span>
<span class="sd">        :param filename_prefix: Prefix to use for filenames of the model pth and encodings files</span>
<span class="sd">        :param dummy_input: Dummy input to the model. Used to parse model graph. It is required for the dummy_input to</span>
<span class="sd">                be placed on CPU.</span>
<span class="sd">        :param onnx_export_args: optional export argument with onnx specific overrides if not provide export via</span>
<span class="sd">                torchscript graph</span>
<span class="sd">        :param propagate_encodings: If True, encoding entries for intermediate ops (when one PyTorch ops results in</span>
<span class="sd">                multiple ONNX nodes) are filled with the same BW and data_type as the output tensor for that series of</span>
<span class="sd">                ops.</span>
<span class="sd">        :return: None</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># save the quantized model and encodings</span>
        <span class="n">model_filename</span> <span class="o">=</span> <span class="n">filename_prefix</span> <span class="o">+</span> <span class="s1">&#39;.pth&#39;</span>
        <span class="n">model_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">model_filename</span><span class="p">)</span>

        <span class="c1"># Create a version of the model without any quantization ops</span>
        <span class="n">model_to_export</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">)</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
        <span class="n">all_modules_in_model_to_export</span> <span class="o">=</span> <span class="p">[</span><span class="n">module</span> <span class="k">for</span> <span class="n">module</span> <span class="ow">in</span> <span class="n">model_to_export</span><span class="o">.</span><span class="n">modules</span><span class="p">()]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_remove_quantization_wrappers</span><span class="p">(</span><span class="n">model_to_export</span><span class="p">,</span> <span class="n">all_modules_in_model_to_export</span><span class="p">)</span>

        <span class="n">torch</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">model_to_export</span><span class="p">,</span> <span class="n">model_path</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">onnx_export_args</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">export_torch_script_model_and_encodings</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">filename_prefix</span><span class="p">,</span> <span class="n">model_to_export</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span>
                                                         <span class="n">dummy_input</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_excluded_layer_names</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">onnx_export_args</span><span class="p">,</span> <span class="n">OnnxExportApiArgs</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">export_onnx_model_and_encodings</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">filename_prefix</span><span class="p">,</span> <span class="n">model_to_export</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span>
                                                 <span class="n">dummy_input</span><span class="p">,</span> <span class="n">onnx_export_args</span><span class="p">,</span> <span class="n">propagate_encodings</span><span class="p">,</span>
                                                 <span class="bp">self</span><span class="o">.</span><span class="n">_module_marker_map</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_conditional</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_excluded_layer_names</span><span class="p">,</span>
                                                 <span class="n">quantizer_args</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">quant_args</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>

            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;unsupported opt_args type=</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">onnx_export_args</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">export_torch_script_model_and_encodings</span><span class="p">(</span><span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">filename_prefix</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                                                <span class="n">original_model</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">,</span>
                                                <span class="n">sim_model</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">,</span>
                                                <span class="n">dummy_input</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">],</span>
                                                <span class="n">excluded_layer_names</span><span class="p">:</span> <span class="n">List</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method exports  a onnx mode and the corresponding encodings</span>

<span class="sd">        :param path: path where to store model pth and encodings</span>
<span class="sd">        :param filename_prefix: Prefix to use for filenames of the model pth and encodings files</span>
<span class="sd">        :param original_model: model without the quantsim wrappers</span>
<span class="sd">        :param sim_model: model with the quantsim wrappers</span>
<span class="sd">        :param dummy_input: Dummy input to the model. Used to parse model graph.</span>
<span class="sd">        :param excluded_layer_names: List of names of layers that have been excluded from quantization.</span>
<span class="sd">        :return: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="n">utils</span><span class="o">.</span><span class="n">in_eval_mode</span><span class="p">(</span><span class="n">original_model</span><span class="p">),</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
            <span class="n">trace</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">jit</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">original_model</span><span class="p">,</span> <span class="n">dummy_input</span><span class="p">)</span>
            <span class="n">ts_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">filename_prefix</span> <span class="o">+</span> <span class="s1">&#39;.torchscript.pth&#39;</span><span class="p">)</span>
            <span class="n">trace</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">ts_path</span><span class="p">)</span>

            <span class="c1"># reload the trace from the saved trace file</span>
            <span class="n">trace</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">jit</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">ts_path</span><span class="p">)</span>
            <span class="n">torch_script_node_io_tensor_map</span><span class="p">,</span> <span class="n">valid_param_set</span> <span class="o">=</span> \
                <span class="n">torchscript_utils</span><span class="o">.</span><span class="n">get_node_to_io_tensor_names_map</span><span class="p">(</span><span class="n">original_model</span><span class="p">,</span> <span class="n">trace</span><span class="p">,</span> <span class="n">dummy_input</span><span class="p">)</span>

        <span class="c1"># Export encodings</span>
        <span class="n">QuantizationSimModel</span><span class="o">.</span><span class="n">_export_encodings_to_files</span><span class="p">(</span><span class="n">sim_model</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">filename_prefix</span><span class="p">,</span>
                                                        <span class="n">torch_script_node_io_tensor_map</span><span class="p">,</span> <span class="n">valid_param_set</span><span class="p">,</span>
                                                        <span class="n">excluded_layer_names</span><span class="p">,</span> <span class="n">propagate_encodings</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">export_onnx_model_and_encodings</span><span class="p">(</span><span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">filename_prefix</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">original_model</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">,</span>
                                        <span class="n">sim_model</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">,</span> <span class="n">dummy_input</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">],</span>
                                        <span class="n">onnx_export_args</span><span class="p">:</span> <span class="n">OnnxExportApiArgs</span><span class="p">,</span> <span class="n">propagate_encodings</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
                                        <span class="n">module_marker_map</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                        <span class="n">is_conditional</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">excluded_layer_names</span><span class="p">:</span> <span class="n">List</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                        <span class="n">quantizer_args</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method exports a onnx model and the corresponding encodings</span>

<span class="sd">        :param path: path where to store model pth and encodings</span>
<span class="sd">        :param filename_prefix: Prefix to use for filenames of the model pth and encodings files</span>
<span class="sd">        :param original_model: model without the quantsim wrappers</span>
<span class="sd">        :param sim_model: model with the quantsim wrappers</span>
<span class="sd">        :param dummy_input: Dummy input to the model. Used to parse model graph.</span>
<span class="sd">        :param onnx_export_args: Additional onnx export args including export api overrides</span>
<span class="sd">        :param propagate_encodings: If True, encoding entries for intermediate ops (when one PyTorch ops results in</span>
<span class="sd">               multiple ONNX nodes) are filled with the same BW and data_type as the output tensor for that series of</span>
<span class="sd">               ops.</span>
<span class="sd">        :param module_marker_map: Maps module names to traced custom markers (only used for conditional models)</span>
<span class="sd">        :param is_conditional: True if model is conditional, False otherwise</span>
<span class="sd">        :param excluded_layer_names: List of names of layers that have been excluded from quantization.</span>
<span class="sd">        :return: None</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># pylint: disable=too-many-locals</span>
        <span class="k">if</span> <span class="n">module_marker_map</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">module_marker_map</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">onnx_export_args</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">onnx_export_args</span> <span class="o">=</span> <span class="n">OnnxExportApiArgs</span><span class="p">()</span>
        <span class="c1"># Save model to onnx</span>
        <span class="n">onnx_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">filename_prefix</span> <span class="o">+</span> <span class="s1">&#39;.onnx&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">dropout_type</span> <span class="ow">in</span> <span class="n">DROPOUT_TYPES</span><span class="p">:</span>
            <span class="n">utils</span><span class="o">.</span><span class="n">replace_modules_of_type1_with_type2</span><span class="p">(</span><span class="n">original_model</span><span class="p">,</span> <span class="n">dropout_type</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Identity</span><span class="p">)</span>

        <span class="n">OnnxSaver</span><span class="o">.</span><span class="n">set_node_names</span><span class="p">(</span><span class="n">onnx_path</span><span class="p">,</span> <span class="n">original_model</span><span class="p">,</span> <span class="n">dummy_input</span><span class="p">,</span> <span class="n">is_conditional</span><span class="p">,</span> <span class="n">module_marker_map</span><span class="p">,</span>
                                 <span class="n">onnx_export_args</span><span class="p">)</span>

        <span class="n">onnx_model</span> <span class="o">=</span> <span class="n">onnx</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">onnx_path</span><span class="p">)</span>
        <span class="n">onnx_node_to_io_tensor_map</span><span class="p">,</span> <span class="n">valid_param_set</span> <span class="o">=</span> <span class="n">OnnxSaver</span><span class="o">.</span><span class="n">get_onnx_node_to_io_tensor_names_map</span><span class="p">(</span><span class="n">onnx_model</span><span class="p">)</span>

        <span class="c1"># Export encodings</span>
        <span class="n">QuantizationSimModel</span><span class="o">.</span><span class="n">_export_encodings_to_files</span><span class="p">(</span><span class="n">sim_model</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">filename_prefix</span><span class="p">,</span>
                                                        <span class="n">onnx_node_to_io_tensor_map</span><span class="p">,</span> <span class="n">valid_param_set</span><span class="p">,</span>
                                                        <span class="n">excluded_layer_names</span><span class="p">,</span> <span class="n">propagate_encodings</span><span class="p">,</span>
                                                        <span class="n">quantizer_args</span><span class="o">=</span><span class="n">quantizer_args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">exclude_layers_from_quantization</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">layers_to_exclude</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Excludes certain layers from being quantized-dequantized by the simulator</span>
<span class="sd">        :param layers_to_exclude: List of torch layers to exclude</span>
<span class="sd">        :return: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Save the excluded layer names. Do not save the modules since the wrapper removal depends on</span>
        <span class="c1"># reference count to automatically remove the layers.</span>
        <span class="n">module_to_name_dict</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">get_module_to_name_dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">)</span>
        <span class="n">quant_layers_to_exclude</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">layer</span> <span class="ow">in</span> <span class="n">layers_to_exclude</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">module</span> <span class="ow">in</span> <span class="n">layer</span><span class="o">.</span><span class="n">modules</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="p">(</span><span class="n">QcQuantizeWrapper</span><span class="p">,</span> <span class="n">QcQuantizeRecurrent</span><span class="p">)):</span>
                    <span class="n">quant_layers_to_exclude</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">module</span><span class="p">)</span>
                    <span class="n">excluded_module_name</span> <span class="o">=</span> <span class="n">module_to_name_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">module</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_excluded_layer_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">excluded_module_name</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_remove_quantization_wrappers</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="n">quant_layers_to_exclude</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">exclude_param_from_quantization</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param_name_to_exclude</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Excludes all parameters matching &#39;param_name&#39; from quantization</span>
<span class="sd">        :param param_name_to_exclude: Name of the parameter to exclude</span>
<span class="sd">        :return: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">module</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">modules</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="p">(</span><span class="n">QcQuantizeWrapper</span><span class="p">,</span> <span class="n">QcQuantizeRecurrent</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">param_name_to_exclude</span> <span class="ow">in</span> <span class="n">module</span><span class="o">.</span><span class="n">param_quantizers</span><span class="p">:</span>
                    <span class="n">module</span><span class="o">.</span><span class="n">param_quantizers</span><span class="p">[</span><span class="n">param_name_to_exclude</span><span class="p">]</span><span class="o">.</span><span class="n">enabled</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_replace_quantization_wrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">device</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Recursively remove quantization wrappers from all appropriate modules starting with a given module</span>
<span class="sd">        :param model: model for which PostTrainingWrapper gets replaced with Trainable wrapped module</span>
<span class="sd">        :param device: device on which model is present</span>
<span class="sd">        :return: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">module_name</span><span class="p">,</span> <span class="n">module_ref</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">named_children</span><span class="p">():</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">module_ref</span><span class="p">,</span> <span class="n">StaticGridQuantWrapper</span><span class="p">):</span>
                <span class="c1"># Create a Trainable wrapper and copy properties of PostTrainingWrapper to the Trainable wrapper</span>
                <span class="n">quantized_module</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_construct_and_initialize_trainable_wrapper</span><span class="p">(</span><span class="n">module_ref</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">module_name</span><span class="p">,</span> <span class="n">quantized_module</span><span class="p">)</span>

            <span class="c1"># Recursively call children modules if present</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">utils</span><span class="o">.</span><span class="n">is_leaf_module</span><span class="p">(</span><span class="n">module_ref</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_replace_quantization_wrapper</span><span class="p">(</span><span class="n">module_ref</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_construct_and_initialize_trainable_wrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">post_training_module</span><span class="p">:</span> <span class="n">StaticGridQuantWrapper</span><span class="p">,</span>
                                                    <span class="n">device</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">LearnedGridQuantWrapper</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Copies following tensor quantizer attributes from StaticGridQuantWrapper to LearnedGridQuantWrapper</span>
<span class="sd">        to avoid any mismatch.</span>
<span class="sd">            - enabled</span>
<span class="sd">            - bitwidth</span>
<span class="sd">            - encoding</span>
<span class="sd">            - use_symmetric_encodings</span>
<span class="sd">            - use_strict_symmetric</span>
<span class="sd">            - use_unsigned_symmetric</span>

<span class="sd">        :param post_training_module: StaticGridQuantWrapper wrapped module</span>
<span class="sd">        :param device: device on which model is present</span>
<span class="sd">        :return: trainable_module: QcTrainable wrapper module</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">_copy_quantizer_attributes</span><span class="p">(</span><span class="n">new_quantizer</span><span class="p">:</span> <span class="n">LearnedGridTensorQuantizer</span><span class="p">,</span>
                                       <span class="n">old_quantizer</span><span class="p">:</span> <span class="n">StaticGridTensorQuantizer</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Copy quantizer attributes from old quantizer to new quantizer.</span>

<span class="sd">            :param new_quantizer: New quantizer</span>
<span class="sd">            :param old_quantizer: Old quantizer</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">new_quantizer</span><span class="o">.</span><span class="n">enabled</span> <span class="o">=</span> <span class="n">old_quantizer</span><span class="o">.</span><span class="n">enabled</span>
            <span class="n">new_quantizer</span><span class="o">.</span><span class="n">bitwidth</span> <span class="o">=</span> <span class="n">old_quantizer</span><span class="o">.</span><span class="n">bitwidth</span>
            <span class="n">new_quantizer</span><span class="o">.</span><span class="n">data_type</span> <span class="o">=</span> <span class="n">old_quantizer</span><span class="o">.</span><span class="n">data_type</span>

            <span class="n">new_quantizer</span><span class="o">.</span><span class="n">use_symmetric_encodings</span> <span class="o">=</span> <span class="n">old_quantizer</span><span class="o">.</span><span class="n">use_symmetric_encodings</span>
            <span class="n">new_quantizer</span><span class="o">.</span><span class="n">use_strict_symmetric</span> <span class="o">=</span> <span class="n">old_quantizer</span><span class="o">.</span><span class="n">use_strict_symmetric</span>
            <span class="n">new_quantizer</span><span class="o">.</span><span class="n">use_unsigned_symmetric</span> <span class="o">=</span> <span class="n">old_quantizer</span><span class="o">.</span><span class="n">use_unsigned_symmetric</span>
            <span class="c1"># NOTE: Set is_unsigned_symmetric to False for learned grid quantizers</span>
            <span class="c1"># This is for the purpose of preventing unsigned symmetric operation</span>
            <span class="c1">#   during QAT 2.0 range learning</span>
            <span class="n">new_quantizer</span><span class="o">.</span><span class="n">is_unsigned_symmetric</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="k">if</span> <span class="n">new_quantizer</span><span class="o">.</span><span class="n">data_type</span> <span class="o">==</span> <span class="n">QuantizationDataType</span><span class="o">.</span><span class="n">float</span> <span class="ow">or</span> <span class="n">new_quantizer</span><span class="o">.</span><span class="n">bitwidth</span> <span class="o">==</span> <span class="mi">32</span><span class="p">:</span>
                <span class="n">new_quantizer</span><span class="o">.</span><span class="n">encoding</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">return</span>

            <span class="c1"># NOTE: Before copying encoding, we do below logic to keep symmetry for range learning</span>
            <span class="c1"># Without below logic, min/max value in symmetric scheme will be</span>
            <span class="c1">#   max = delta * floor(num_steps / 2)</span>
            <span class="c1">#   min = -delta * floor(num_steps / 2) - delta =&gt; One more bin to represent</span>
            <span class="c1"># With below logic,</span>
            <span class="c1">#   max = delta * floor(num_steps / 2)</span>
            <span class="c1">#   min = -delta * floor(num_steps / 2) = -max</span>
            <span class="c1">#   which matches with strict symmetric scheme</span>
            <span class="k">if</span> <span class="n">old_quantizer</span><span class="o">.</span><span class="n">enabled</span> <span class="ow">and</span> \
                    <span class="n">old_quantizer</span><span class="o">.</span><span class="n">use_symmetric_encodings</span> <span class="ow">and</span> \
                    <span class="ow">not</span> <span class="n">old_quantizer</span><span class="o">.</span><span class="n">is_unsigned_symmetric</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">old_quantizer</span><span class="o">.</span><span class="n">encoding</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">encoding</span> <span class="ow">in</span> <span class="n">old_quantizer</span><span class="o">.</span><span class="n">encoding</span><span class="p">:</span>
                        <span class="n">encoding</span><span class="o">.</span><span class="n">min</span> <span class="o">=</span> <span class="o">-</span><span class="n">encoding</span><span class="o">.</span><span class="n">max</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">old_quantizer</span><span class="o">.</span><span class="n">encoding</span><span class="o">.</span><span class="n">min</span> <span class="o">=</span> <span class="o">-</span><span class="n">old_quantizer</span><span class="o">.</span><span class="n">encoding</span><span class="o">.</span><span class="n">max</span>

            <span class="c1"># NOTE: In range learning, we do calculation with non-strict symmetric way</span>
            <span class="c1">#   even if unsigned symmetric conditions are satisfied</span>
            <span class="c1"># Make the min value symmetric with max, and update the corresponding delta and offset</span>
            <span class="k">if</span> <span class="n">old_quantizer</span><span class="o">.</span><span class="n">enabled</span> <span class="ow">and</span> <span class="n">old_quantizer</span><span class="o">.</span><span class="n">is_unsigned_symmetric</span><span class="p">:</span>
                <span class="n">num_steps</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="n">old_quantizer</span><span class="o">.</span><span class="n">bitwidth</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">half_num_steps</span> <span class="o">=</span> <span class="n">num_steps</span> <span class="o">/</span> <span class="mi">2</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">old_quantizer</span><span class="o">.</span><span class="n">encoding</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">encoding</span> <span class="ow">in</span> <span class="n">old_quantizer</span><span class="o">.</span><span class="n">encoding</span><span class="p">:</span>
                        <span class="n">encoding</span><span class="o">.</span><span class="n">min</span> <span class="o">=</span> <span class="o">-</span><span class="n">encoding</span><span class="o">.</span><span class="n">max</span>
                        <span class="n">encoding</span><span class="o">.</span><span class="n">delta</span> <span class="o">=</span> <span class="n">encoding</span><span class="o">.</span><span class="n">max</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">half_num_steps</span><span class="p">)</span>
                        <span class="n">encoding</span><span class="o">.</span><span class="n">offset</span> <span class="o">=</span> <span class="o">-</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">half_num_steps</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">old_quantizer</span><span class="o">.</span><span class="n">encoding</span><span class="o">.</span><span class="n">min</span> <span class="o">=</span> <span class="o">-</span><span class="n">old_quantizer</span><span class="o">.</span><span class="n">encoding</span><span class="o">.</span><span class="n">max</span>
                    <span class="n">old_quantizer</span><span class="o">.</span><span class="n">encoding</span><span class="o">.</span><span class="n">delta</span> <span class="o">=</span> <span class="n">old_quantizer</span><span class="o">.</span><span class="n">encoding</span><span class="o">.</span><span class="n">max</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">half_num_steps</span><span class="p">)</span>
                    <span class="n">old_quantizer</span><span class="o">.</span><span class="n">encoding</span><span class="o">.</span><span class="n">offset</span> <span class="o">=</span> <span class="o">-</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">half_num_steps</span><span class="p">)</span>

            <span class="n">new_quantizer</span><span class="o">.</span><span class="n">encoding</span> <span class="o">=</span> <span class="n">old_quantizer</span><span class="o">.</span><span class="n">encoding</span>

        <span class="c1"># pylint: disable=protected-access</span>
        <span class="n">module</span> <span class="o">=</span> <span class="n">post_training_module</span><span class="o">.</span><span class="n">_module_to_wrap</span>

        <span class="n">num_inputs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">post_training_module</span><span class="o">.</span><span class="n">input_quantizers</span><span class="p">)</span>
        <span class="n">num_outputs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">post_training_module</span><span class="o">.</span><span class="n">output_quantizers</span><span class="p">)</span>

        <span class="c1"># Creating a LearnedGridQuantWrapper module</span>
        <span class="n">trainable_module</span> <span class="o">=</span> <span class="n">LearnedGridQuantWrapper</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default_param_bw</span><span class="p">,</span>
                                                   <span class="bp">self</span><span class="o">.</span><span class="n">_default_output_bw</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rounding_mode</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quant_scheme</span><span class="p">,</span>
                                                   <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span> <span class="n">num_inputs</span><span class="o">=</span><span class="n">num_inputs</span><span class="p">,</span> <span class="n">num_outputs</span><span class="o">=</span><span class="n">num_outputs</span><span class="p">,</span>
                                                   <span class="n">data_type</span><span class="o">=</span><span class="n">QuantizationDataType</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
        <span class="c1"># Copy user settable attributes for outputs</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">quantizer</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">post_training_module</span><span class="o">.</span><span class="n">output_quantizers</span><span class="p">):</span>
            <span class="n">_copy_quantizer_attributes</span><span class="p">(</span><span class="n">trainable_module</span><span class="o">.</span><span class="n">output_quantizers</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">quantizer</span><span class="p">)</span>
        <span class="c1"># Copy user settable attributes for inputs</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">quantizer</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">post_training_module</span><span class="o">.</span><span class="n">input_quantizers</span><span class="p">):</span>
            <span class="n">_copy_quantizer_attributes</span><span class="p">(</span><span class="n">trainable_module</span><span class="o">.</span><span class="n">input_quantizers</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">quantizer</span><span class="p">)</span>
        <span class="c1"># Copy user settable attributes for params</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">quantizer</span> <span class="ow">in</span> <span class="n">post_training_module</span><span class="o">.</span><span class="n">param_quantizers</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">learned_grid_quantizer</span> <span class="o">=</span> <span class="n">trainable_module</span><span class="o">.</span><span class="n">param_quantizers</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="n">_copy_quantizer_attributes</span><span class="p">(</span><span class="n">learned_grid_quantizer</span><span class="p">,</span> <span class="n">quantizer</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">trainable_module</span>

    <span class="k">def</span> <span class="nf">replace_wrappers_for_quantize_dequantize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Replaces StaticGridWrapper with LearnedGridWrapper</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quant_scheme</span> <span class="o">==</span> <span class="n">QuantScheme</span><span class="o">.</span><span class="n">training_range_learning_with_tf_init</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quant_scheme</span> <span class="o">==</span> \
                <span class="n">QuantScheme</span><span class="o">.</span><span class="n">training_range_learning_with_tf_enhanced_init</span><span class="p">:</span>
            <span class="n">device</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">get_device</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_replace_quantization_wrapper</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_override_quant_config_for_transformer_layers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Looks for specfic ops in a transformer and overrides the quantizer to tf mode</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># pylint: disable=protected-access</span>
        <span class="n">attention_with_mask_add_quantizer_dict</span> <span class="o">=</span> <span class="n">transformer_utils</span><span class="o">.</span><span class="n">get_attention_with_mask_add_quantizer_dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">attention_head</span><span class="p">,</span> <span class="p">(</span><span class="n">mask_add_quantizer_wrapper</span><span class="p">,</span> <span class="n">mask_add_name</span><span class="p">)</span> <span class="ow">in</span> <span class="n">attention_with_mask_add_quantizer_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mask_add_quantizer_wrapper</span><span class="p">,</span> <span class="n">StaticGridQuantWrapper</span><span class="p">)</span>

            <span class="c1"># clamping needs to be done only if data type is int</span>
            <span class="k">if</span> <span class="n">mask_add_quantizer_wrapper</span><span class="o">.</span><span class="n">output_quantizers</span> <span class="ow">and</span> \
                    <span class="n">mask_add_quantizer_wrapper</span><span class="o">.</span><span class="n">output_quantizers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data_type</span> <span class="o">==</span> <span class="n">QuantizationDataType</span><span class="o">.</span><span class="n">int</span><span class="p">:</span>

                <span class="n">module_to_quantize</span> <span class="o">=</span> <span class="n">mask_add_quantizer_wrapper</span><span class="o">.</span><span class="n">_module_to_wrap</span>

                <span class="n">quantizer_wrapper_type</span> <span class="o">=</span> <span class="n">qc_quantize_modules_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">module_to_quantize</span><span class="p">),</span> <span class="n">StaticGridQuantWrapper</span><span class="p">)</span>

                <span class="c1"># Add a quantizer set to tf mode and bw to 16 and copy over remaining attributes</span>
                <span class="c1"># we need 16 bit to retain the max representation for this quantizer.</span>
                <span class="n">quantized_module</span> <span class="o">=</span> <span class="n">quantizer_wrapper_type</span><span class="p">(</span><span class="n">module_to_quantize</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span>
                                                          <span class="n">MAP_PYMO_TO_ROUND_MODE</span><span class="p">[</span><span class="n">mask_add_quantizer_wrapper</span><span class="o">.</span><span class="n">output_quantizers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">round_mode</span><span class="p">],</span>
                                                          <span class="n">QuantScheme</span><span class="o">.</span><span class="n">post_training_tf</span><span class="p">,</span>
                                                          <span class="n">num_inputs</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">mask_add_quantizer_wrapper</span><span class="o">.</span><span class="n">input_quantizers</span><span class="p">),</span>
                                                          <span class="n">num_outputs</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">mask_add_quantizer_wrapper</span><span class="o">.</span><span class="n">output_quantizers</span><span class="p">),</span>
                                                          <span class="n">data_type</span><span class="o">=</span><span class="n">mask_add_quantizer_wrapper</span><span class="o">.</span><span class="n">output_quantizers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data_type</span><span class="p">)</span>

                <span class="nb">setattr</span><span class="p">(</span><span class="n">attention_head</span><span class="p">,</span> <span class="n">mask_add_name</span><span class="p">,</span> <span class="n">quantized_module</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_clamp_transformer_attention_mask_encoding</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        clamps the quantizer encoding min associated with mask adder</span>
<span class="sd">        op within a attention head.</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># pylint: disable=protected-access</span>
        <span class="n">attention_with_mask_add_quantizer_dict</span> <span class="o">=</span> <span class="n">transformer_utils</span><span class="o">.</span><span class="n">get_attention_with_mask_add_quantizer_dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">)</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">mask_add_quantizer_wrapper</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="ow">in</span> <span class="n">attention_with_mask_add_quantizer_dict</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="c1"># we check if quantizer is enabled and data type is set to int before clamping</span>
            <span class="c1"># clamping is not necessary for FP16 mode.</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mask_add_quantizer_wrapper</span><span class="p">,</span> <span class="n">StaticGridQuantWrapper</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">mask_add_quantizer_wrapper</span><span class="o">.</span><span class="n">output_quantizers</span> <span class="ow">and</span> <span class="n">mask_add_quantizer_wrapper</span><span class="o">.</span><span class="n">output_quantizers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">enabled</span> \
                    <span class="ow">and</span> <span class="n">mask_add_quantizer_wrapper</span><span class="o">.</span><span class="n">output_quantizers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data_type</span> <span class="o">==</span> <span class="n">QuantizationDataType</span><span class="o">.</span><span class="n">int</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">output_quantizer</span> <span class="ow">in</span> <span class="n">mask_add_quantizer_wrapper</span><span class="o">.</span><span class="n">output_quantizers</span><span class="p">:</span>
                    <span class="c1"># get the min/max from accumulated stats associated with this quantizer</span>
                    <span class="k">if</span> <span class="n">output_quantizer</span><span class="o">.</span><span class="n">is_encoding_frozen</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">encoding</span> <span class="o">=</span> <span class="n">output_quantizer</span><span class="o">.</span><span class="n">encoding</span>
                    <span class="n">output_quantizer</span><span class="o">.</span><span class="n">encoding</span><span class="o">.</span><span class="n">min</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">encoding</span><span class="o">.</span><span class="n">min</span><span class="p">,</span>
                                                        <span class="n">transformer_utils</span><span class="o">.</span><span class="n">MASK_OVERRIDE_VALUE</span><span class="p">)</span>
                    <span class="n">output_quantizer</span><span class="o">.</span><span class="n">encoding</span><span class="o">.</span><span class="n">max</span> <span class="o">=</span> <span class="n">encoding</span><span class="o">.</span><span class="n">max</span>

                    <span class="c1"># recompute grid params as we clamped min and updated max above</span>
                    <span class="c1"># with bitwidth as dictated by default config</span>
                    <span class="n">clamped_encoding</span> <span class="o">=</span> <span class="n">aimet_common</span><span class="o">.</span><span class="n">quantsim</span><span class="o">.</span><span class="n">recompute_grid_params</span><span class="p">(</span>
                        <span class="n">output_quantizer</span><span class="o">.</span><span class="n">encoding</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_default_output_bw</span><span class="p">,</span>
                        <span class="n">output_quantizer</span><span class="o">.</span><span class="n">use_symmetric_encodings</span><span class="p">)</span>

                    <span class="c1"># update encoding of this quantizer</span>
                    <span class="n">output_quantizer</span><span class="o">.</span><span class="n">encoding</span> <span class="o">=</span> <span class="n">clamped_encoding</span>
                    <span class="n">output_quantizer</span><span class="o">.</span><span class="n">freeze_encoding</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Skipping clamp on </span><span class="si">%s</span><span class="s2">. Quantizer is disabled or not int type&quot;</span><span class="p">,</span>
                             <span class="n">mask_add_quantizer_wrapper</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_validate_quantsim_inputs</span><span class="p">(</span><span class="n">quant_scheme</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">QuantScheme</span><span class="p">],</span> <span class="n">rounding_mode</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">default_output_bw</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                                  <span class="n">default_param_bw</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">data_type</span><span class="p">:</span> <span class="n">QuantizationDataType</span> <span class="o">=</span> <span class="n">QuantizationDataType</span><span class="o">.</span><span class="n">int</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform sanity checks on inputs to QuantSim</span>

<span class="sd">        NOTE: This method will be deprecated.</span>
<span class="sd">              Call aimet_common.quantsim.validate_quantsim_inputs directly instead.</span>

<span class="sd">        :param quant_scheme: Quantization scheme. Supported options are &#39;tf_enhanced&#39; or &#39;tf&#39; or using Quant Scheme Enum</span>
<span class="sd">                             QuantScheme.post_training_tf or QuantScheme.post_training_tf_enhanced</span>
<span class="sd">        :param rounding_mode: Rounding mode. Supported options are &#39;nearest&#39; or &#39;stochastic&#39;</span>
<span class="sd">        :param default_output_bw: Default bitwidth (4-31) to use for quantizing layer inputs and outputs</span>
<span class="sd">        :param default_param_bw: Default bitwidth (4-31) to use for quantizing layer parameters</span>
<span class="sd">        :param data_type: Data type of the quantized values (int or float).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">validate_quantsim_inputs</span><span class="p">(</span><span class="n">quant_scheme</span><span class="p">,</span>
                                 <span class="n">rounding_mode</span><span class="p">,</span>
                                 <span class="n">default_output_bw</span><span class="p">,</span>
                                 <span class="n">default_param_bw</span><span class="p">,</span>
                                 <span class="n">data_type</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_find_next_downstream_modules</span><span class="p">(</span><span class="n">op</span><span class="p">):</span>
        <span class="n">downstream_modules</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">succeeding_op</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">output</span><span class="o">.</span><span class="n">consumers</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">succeeding_op</span><span class="o">.</span><span class="n">get_module</span><span class="p">():</span>
                <span class="n">downstream_modules</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">succeeding_op</span><span class="o">.</span><span class="n">get_module</span><span class="p">())</span>

            <span class="k">elif</span> <span class="n">succeeding_op</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;Split&#39;</span><span class="p">:</span>
                <span class="n">downstream_modules</span> <span class="o">+=</span> <span class="n">QuantizationSimModel</span><span class="o">.</span><span class="n">_find_next_downstream_modules</span><span class="p">(</span><span class="n">succeeding_op</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">downstream_modules</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_export_encodings_to_files</span><span class="p">(</span><span class="n">sim_model</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">filename_prefix</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                                   <span class="n">op_to_io_tensor_map</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">valid_param_set</span><span class="p">:</span> <span class="nb">set</span><span class="p">,</span> <span class="n">excluded_layer_names</span><span class="p">,</span>
                                   <span class="n">propagate_encodings</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">quantizer_args</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save the quantized model weight encodings</span>

<span class="sd">        :param sim_model: Quantsim model to export encodings for</span>
<span class="sd">        :param path: path where to store model pth and encodings</span>
<span class="sd">        :param filename_prefix: filename to store exported weight encodings in json format</span>
<span class="sd">        :param op_to_io_tensor_map: Dictionary of layer to I/O tensor mapping from onnx or torch script model</span>
<span class="sd">        :param valid_param_set: a set of valid param input names in model</span>
<span class="sd">        :param excluded_layer_names: List of names of layers that have been excluded from quantization.</span>
<span class="sd">        :param propagate_encodings: If True, encoding entries for intermediate ops (when one PyTorch ops results in</span>
<span class="sd">                multiple ONNX nodes) are filled with the same BW and data_type as the output tensor for that series of</span>
<span class="sd">                ops.</span>
<span class="sd">        :param quantizer_args</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># pylint: disable=too-many-locals</span>

        <span class="c1"># Create a dictionary to export to JSON</span>
        <span class="n">activation_encodings_onnx</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">activation_encodings_torch</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">param_encodings</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">layers_in_io_tensor</span> <span class="o">=</span> <span class="n">QuantizationSimModel</span><span class="o">.</span><span class="n">_get_layers_in_io_tensor_map</span><span class="p">(</span><span class="n">op_to_io_tensor_map</span><span class="p">)</span>

        <span class="n">layer_names_not_found</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">layer_name</span><span class="p">,</span> <span class="n">layer</span> <span class="ow">in</span> <span class="n">QuantizationSimModel</span><span class="o">.</span><span class="n">_get_qc_quantized_layers</span><span class="p">(</span><span class="n">sim_model</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">has_valid_encodings</span><span class="p">(</span><span class="n">layer</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="c1"># TODO: specifically call out dropout layers here since they are specifically switched out during export.</span>
            <span class="c1"># These ops should eventually be reworked as part of math invariant ops to ignore quantization altogether.</span>
            <span class="c1"># pylint: disable=protected-access</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="n">QcQuantizeWrapper</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">layer</span><span class="o">.</span><span class="n">_module_to_wrap</span><span class="p">,</span> <span class="n">DROPOUT_TYPES</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">layer_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">layers_in_io_tensor</span><span class="p">:</span>
                <span class="n">layer_names_not_found</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">layer_name</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">QuantizationSimModel</span><span class="o">.</span><span class="n">_update_encoding_dicts_for_layer</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="n">layer_name</span><span class="p">,</span> <span class="n">activation_encodings_onnx</span><span class="p">,</span>
                                                                      <span class="n">activation_encodings_torch</span><span class="p">,</span>
                                                                      <span class="n">param_encodings</span><span class="p">,</span> <span class="n">op_to_io_tensor_map</span><span class="p">,</span>
                                                                      <span class="n">valid_param_set</span><span class="p">,</span> <span class="n">propagate_encodings</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">layer_names_not_found</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;The following layers were not found in the exported onnx model. Encodings for these layers&quot;</span>
                           <span class="s2">&quot; will not appear in the exported encodings file:</span><span class="se">\n</span><span class="s2">&quot;</span>
                           <span class="s2">&quot;</span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span>
                           <span class="s2">&quot;This can be due to several reasons:</span><span class="se">\n</span><span class="s2">&quot;</span>
                           <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">- The layer is set to quantize with float datatype, but was not exercised in compute &quot;</span>
                           <span class="s2">&quot;encodings. Not an issue if the layer is not meant to be run.</span><span class="se">\n</span><span class="s2">&quot;</span>
                           <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">- The layer has valid encodings but was not seen while exporting to onnx using the dummy &quot;</span>
                           <span class="s2">&quot;input provided in sim.export(). Ensure that the dummy input covers all layers.&quot;</span><span class="p">,</span>
                           <span class="n">layer_names_not_found</span><span class="p">)</span>
        <span class="n">encodings_dict_onnx</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;version&#39;</span><span class="p">:</span> <span class="n">encoding_version</span><span class="p">,</span>
                               <span class="s1">&#39;activation_encodings&#39;</span><span class="p">:</span> <span class="n">activation_encodings_onnx</span><span class="p">,</span>
                               <span class="s1">&#39;param_encodings&#39;</span><span class="p">:</span> <span class="n">param_encodings</span><span class="p">,</span>
                               <span class="s1">&#39;excluded_layers&#39;</span><span class="p">:</span> <span class="n">excluded_layer_names</span><span class="p">}</span>

        <span class="n">encodings_dict_pytorch</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;version&#39;</span><span class="p">:</span> <span class="n">encoding_version</span><span class="p">,</span>
                                  <span class="s1">&#39;activation_encodings&#39;</span><span class="p">:</span> <span class="n">activation_encodings_torch</span><span class="p">,</span>
                                  <span class="s1">&#39;param_encodings&#39;</span><span class="p">:</span> <span class="n">param_encodings</span><span class="p">,</span>
                                  <span class="s1">&#39;excluded_layers&#39;</span><span class="p">:</span> <span class="n">excluded_layer_names</span><span class="p">}</span>

        <span class="k">if</span> <span class="n">quantizer_args</span><span class="p">:</span>
            <span class="n">encodings_dict_pytorch</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;quantizer_args&#39;</span><span class="p">:</span> <span class="n">quantizer_args</span><span class="p">})</span>
            <span class="n">encodings_dict_onnx</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;quantizer_args&#39;</span><span class="p">:</span> <span class="n">quantizer_args</span><span class="p">})</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Layers excluded from quantization: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">excluded_layer_names</span><span class="p">)</span>

        <span class="c1"># export weight encodings to output json file</span>
        <span class="n">encoding_file_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">filename_prefix</span> <span class="o">+</span> <span class="s1">&#39;.encodings&#39;</span><span class="p">)</span>
        <span class="n">encoding_file_path_pytorch</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">filename_prefix</span> <span class="o">+</span> <span class="s1">&#39;_torch&#39;</span> <span class="o">+</span> <span class="s1">&#39;.encodings&#39;</span><span class="p">)</span>
        <span class="n">save_json_yaml</span><span class="p">(</span><span class="n">encoding_file_path</span><span class="p">,</span> <span class="n">encodings_dict_onnx</span><span class="p">)</span>
        <span class="n">save_json_yaml</span><span class="p">(</span><span class="n">encoding_file_path_pytorch</span><span class="p">,</span> <span class="n">encodings_dict_pytorch</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_layers_in_io_tensor_map</span><span class="p">(</span><span class="n">op_to_io_tensor_map</span><span class="p">:</span> <span class="n">Dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        extract root(layer) names of onnx op names in tensor map</span>
<span class="sd">        :param op_to_io_tensor_map: ONNX or Torch Script map of layer name to it&#39;s input/output tensors</span>
<span class="sd">        :return: a set containing layer names present in io tensor map.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">layers_in_io_tensor_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">op_to_io_tensor_map</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.end&#39;</span><span class="p">):</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="p">[:</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span>
            <span class="n">layers_in_io_tensor_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;#&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">layers_in_io_tensor_set</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_update_param_encodings_dict_for_layer</span><span class="p">(</span><span class="n">layer</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">,</span> <span class="n">layer_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">param_encodings</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span>
                                               <span class="n">valid_param_set</span><span class="p">:</span> <span class="nb">set</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param layer: layer as torch.nn.Module</span>
<span class="sd">        :param layer_name : Name of the layer</span>
<span class="sd">        :param param_encodings: dictionary of param encodings</span>
<span class="sd">        :param valid_param_set: a set of valid param input names in model</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">orig_param_name</span><span class="p">,</span> <span class="n">param_quantizer</span> <span class="ow">in</span> <span class="n">layer</span><span class="o">.</span><span class="n">param_quantizers</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">param_name</span> <span class="o">=</span> <span class="n">layer_name</span> <span class="o">+</span> <span class="s1">&#39;.&#39;</span> <span class="o">+</span> <span class="n">orig_param_name</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">param_quantizer</span><span class="o">.</span><span class="n">enabled</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">elif</span> <span class="n">param_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">valid_param_set</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Param tensor {</span><span class="si">%s</span><span class="s1">} not found in valid param set&#39;</span><span class="p">,</span> <span class="n">param_name</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">param_quantizer</span><span class="o">.</span><span class="n">encoding</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
                <span class="n">param_encodings</span><span class="p">[</span><span class="n">param_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">quantizer_encoding</span> <span class="o">=</span> <span class="n">_get_encoding_by_quantizer</span><span class="p">(</span><span class="n">param_quantizer</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">encoding</span> <span class="ow">in</span> <span class="n">quantizer_encoding</span><span class="p">:</span>
                    <span class="n">enc_dict</span> <span class="o">=</span> <span class="n">QuantizationSimModel</span><span class="o">.</span><span class="n">_create_encoding_dict</span><span class="p">(</span><span class="n">encoding</span><span class="p">,</span>
                                                                          <span class="n">param_quantizer</span><span class="p">,</span> <span class="n">propagate_encodings</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="n">param_encodings</span><span class="p">[</span><span class="n">param_name</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">enc_dict</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">quantizer_encoding</span> <span class="o">=</span> <span class="n">_get_encoding_by_quantizer</span><span class="p">(</span><span class="n">param_quantizer</span><span class="p">)</span>
                <span class="n">enc_dict</span> <span class="o">=</span> <span class="n">QuantizationSimModel</span><span class="o">.</span><span class="n">_create_encoding_dict</span><span class="p">(</span><span class="n">quantizer_encoding</span><span class="p">,</span> <span class="n">param_quantizer</span><span class="p">,</span>
                                                                      <span class="n">propagate_encodings</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">param_encodings</span><span class="p">[</span><span class="n">param_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">enc_dict</span><span class="p">]</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_update_encoding_dicts_for_layer</span><span class="p">(</span><span class="n">layer</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">,</span> <span class="n">layer_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">activation_encodings_onnx</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span>
                                         <span class="n">activation_encodings_torch</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">param_encodings</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span>
                                         <span class="n">op_to_io_tensor_map</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">valid_param_set</span><span class="p">:</span> <span class="nb">set</span><span class="p">,</span> <span class="n">propagate_encodings</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add given layer param and activation encodings to respective dictionaries to be used for exporting encodings</span>
<span class="sd">        :param layer: layer as torch.nn.Module</span>
<span class="sd">        :param layer_name: Name of the layer</span>
<span class="sd">        :param activation_encodings_onnx: dictionary of activation encodings which maps onnx attribute to encodings</span>
<span class="sd">        :param activation_encodings_torch: dictionary of activation encodings which maps pytorch names to encodings</span>
<span class="sd">        :param param_encodings: dictionary of param encodings</span>
<span class="sd">        :param op_to_io_tensor_map: ONNX or Torch Script map of layer name to it&#39;s input/output tensors</span>
<span class="sd">        :param valid_param_set: a set of valid param input names in model</span>
<span class="sd">        :param propagate_encodings: If True, encoding entries for intermediate ops (when one PyTorch ops results in</span>
<span class="sd">                multiple ONNX nodes) are filled with the same BW and data_type as the output tensor for that series of</span>
<span class="sd">                ops.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="n">QcQuantizeWrapper</span><span class="p">):</span>

            <span class="c1"># --------------------------------------</span>
            <span class="c1"># Update encodings for Input activations</span>
            <span class="c1"># --------------------------------------</span>
            <span class="n">QuantizationSimModel</span><span class="o">.</span><span class="n">_update_encoding_dict_for_input_activations</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="n">layer_name</span><span class="p">,</span> <span class="n">op_to_io_tensor_map</span><span class="p">,</span>
                                                                             <span class="n">activation_encodings_onnx</span><span class="p">,</span>
                                                                             <span class="n">activation_encodings_torch</span><span class="p">)</span>
            <span class="c1"># ---------------------------------------</span>
            <span class="c1"># Update encodings for output activations</span>
            <span class="c1"># ---------------------------------------</span>
            <span class="n">QuantizationSimModel</span><span class="o">.</span><span class="n">_update_encoding_dict_for_output_activations</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="n">layer_name</span><span class="p">,</span>
                                                                              <span class="n">op_to_io_tensor_map</span><span class="p">,</span>
                                                                              <span class="n">activation_encodings_onnx</span><span class="p">,</span>
                                                                              <span class="n">activation_encodings_torch</span><span class="p">,</span>
                                                                              <span class="n">propagate_encodings</span><span class="p">)</span>
            <span class="c1"># ---------------------------</span>
            <span class="c1"># Update encodings for Params</span>
            <span class="c1"># ---------------------------</span>
            <span class="n">QuantizationSimModel</span><span class="o">.</span><span class="n">_update_param_encodings_dict_for_layer</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="n">layer_name</span><span class="p">,</span> <span class="n">param_encodings</span><span class="p">,</span>
                                                                        <span class="n">valid_param_set</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="n">QcQuantizeRecurrent</span><span class="p">):</span>
            <span class="c1"># Update encodings for Recurrent layers</span>
            <span class="n">QuantizationSimModel</span><span class="o">.</span><span class="n">_update_encoding_dict_for_recurrent_layers</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="n">layer_name</span><span class="p">,</span> <span class="n">op_to_io_tensor_map</span><span class="p">,</span>
                                                                            <span class="n">activation_encodings_onnx</span><span class="p">,</span>
                                                                            <span class="n">param_encodings</span><span class="p">,</span> <span class="n">propagate_encodings</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">find_op_names_for_layer</span><span class="p">(</span><span class="n">layer_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">op_to_io_tensor_map</span><span class="p">:</span> <span class="n">Dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function returns the last ONNX op and the list of ONNX Ops that were mapped from a PyTorch Op.</span>

<span class="sd">        :param layer_name: Name of the PyTorch layer</span>
<span class="sd">        :param op_to_io_tensor_map: ONNX or Torch Script map of layer name to it&#39;s input/output tensors</span>
<span class="sd">        :return: tuple(end op names, all op names)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">op_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">key</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">op_to_io_tensor_map</span> <span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">layer_name</span><span class="p">)</span> <span class="ow">and</span> <span class="n">layer_name</span><span class="o">+</span><span class="s1">&#39;#&#39;</span> <span class="ow">in</span> <span class="n">key</span><span class="p">)</span>
                    <span class="ow">or</span> <span class="n">key</span> <span class="o">==</span> <span class="n">layer_name</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">op_names</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">op_names</span><span class="p">,</span> <span class="n">op_names</span>

        <span class="n">end_op_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">op_name</span> <span class="k">for</span> <span class="n">op_name</span> <span class="ow">in</span> <span class="n">op_names</span> <span class="k">if</span> <span class="n">op_name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.end&#39;</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">end_op_names</span><span class="p">,</span> <span class="n">op_names</span>


    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_update_encoding_dict_for_output_activations</span><span class="p">(</span><span class="n">layer</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">,</span> <span class="n">layer_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">op_to_io_tensor_map</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span>
                                                     <span class="n">activation_encodings_onnx</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">activation_encodings_torch</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span>
                                                     <span class="n">propagate_encodings</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="c1"># pylint: disable=too-many-locals</span>
        <span class="n">output_tensors</span><span class="p">,</span> <span class="n">propagate_tensors</span> <span class="o">=</span> <span class="n">QuantizationSimModel</span><span class="o">.</span><span class="n">_get_layer_activation_tensors</span><span class="p">(</span><span class="n">layer_name</span><span class="p">,</span>
                                                                                               <span class="n">op_to_io_tensor_map</span><span class="p">)</span>
        <span class="n">num_quantizers</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">layer</span><span class="o">.</span><span class="n">output_quantizers</span><span class="p">)</span>
        <span class="n">num_outputs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">output_tensors</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">output_tensors</span><span class="p">)</span> <span class="o">!=</span> <span class="n">num_quantizers</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;number of output quantizers: </span><span class="si">%d</span><span class="s2"> available for layer: </span><span class="si">%s</span><span class="s2"> &quot;</span>
                           <span class="s2">&quot;doesn&#39;t match with number of output tensors: </span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">num_quantizers</span><span class="p">,</span> <span class="n">layer_name</span><span class="p">,</span> <span class="n">num_outputs</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="p">(</span><span class="n">output_tensor</span><span class="p">,</span> <span class="n">quantizer</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">output_tensors</span><span class="p">,</span> <span class="n">layer</span><span class="o">.</span><span class="n">output_quantizers</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">quantizer</span><span class="o">.</span><span class="n">enabled</span><span class="p">:</span>
                <span class="n">quantizer_encoding</span> <span class="o">=</span> <span class="n">_get_encoding_by_quantizer</span><span class="p">(</span><span class="n">quantizer</span><span class="p">)</span>
                <span class="n">enc</span> <span class="o">=</span> <span class="n">QuantizationSimModel</span><span class="o">.</span><span class="n">_create_encoding_dict</span><span class="p">(</span><span class="n">quantizer_encoding</span><span class="p">,</span>
                                                                 <span class="n">quantizer</span><span class="p">,</span>
                                                                 <span class="n">propagate_encodings</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">activation_encodings_onnx</span><span class="p">[</span><span class="n">output_tensor</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">enc</span><span class="p">]</span>

                <span class="c1"># Check if layer exists in the pytorch encoding dictionary</span>
                <span class="k">if</span> <span class="n">layer_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">activation_encodings_torch</span><span class="p">:</span>
                    <span class="n">activation_encodings_torch</span><span class="p">[</span><span class="n">layer_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">if</span> <span class="n">QUANTIZER_TYPE_OUTPUT</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">activation_encodings_torch</span><span class="p">[</span><span class="n">layer_name</span><span class="p">]:</span>
                    <span class="n">activation_encodings_torch</span><span class="p">[</span><span class="n">layer_name</span><span class="p">][</span><span class="n">QUANTIZER_TYPE_OUTPUT</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="n">activation_encodings_torch</span><span class="p">[</span><span class="n">layer_name</span><span class="p">][</span><span class="n">QUANTIZER_TYPE_OUTPUT</span><span class="p">][</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">enc</span>

        <span class="k">if</span> <span class="n">propagate_encodings</span><span class="p">:</span>
            <span class="n">enabled_quantizers</span> <span class="o">=</span> <span class="p">[</span><span class="n">q</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">layer</span><span class="o">.</span><span class="n">output_quantizers</span> <span class="k">if</span> <span class="n">q</span><span class="o">.</span><span class="n">enabled</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">enabled_quantizers</span><span class="p">:</span>
                <span class="n">quantizer</span> <span class="o">=</span> <span class="n">enabled_quantizers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">activation_tensor</span> <span class="ow">in</span> <span class="n">propagate_tensors</span><span class="p">:</span>
                    <span class="n">quantizer_encoding</span> <span class="o">=</span> <span class="n">_get_encoding_by_quantizer</span><span class="p">(</span><span class="n">quantizer</span><span class="p">)</span>
                    <span class="n">enc</span> <span class="o">=</span> <span class="n">QuantizationSimModel</span><span class="o">.</span><span class="n">_create_encoding_dict</span><span class="p">(</span><span class="n">quantizer_encoding</span><span class="p">,</span>
                                                                     <span class="n">quantizer</span><span class="p">,</span>
                                                                     <span class="n">propagate_encodings</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">activation_encodings_onnx</span><span class="p">[</span><span class="n">activation_tensor</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">enc</span><span class="p">]</span>


    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_update_encoding_dict_for_input_activations</span><span class="p">(</span><span class="n">layer</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">,</span> <span class="n">layer_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">op_to_io_tensor_map</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span>
                                                    <span class="n">activation_encodings_onnx</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">activation_encodings_torch</span><span class="p">:</span> <span class="n">Dict</span><span class="p">):</span>

        <span class="c1"># skip layer if all input quantizers are disabled.</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="ow">not</span> <span class="n">quantizer</span><span class="o">.</span><span class="n">enabled</span> <span class="k">for</span> <span class="n">quantizer</span> <span class="ow">in</span> <span class="n">layer</span><span class="o">.</span><span class="n">input_quantizers</span><span class="p">):</span>
            <span class="k">return</span>

        <span class="n">input_tensors</span> <span class="o">=</span> <span class="n">QuantizationSimModel</span><span class="o">.</span><span class="n">_get_layer_input_tensors</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="n">layer_name</span><span class="p">,</span> <span class="n">op_to_io_tensor_map</span><span class="p">)</span>
        <span class="n">num_quantizers</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">layer</span><span class="o">.</span><span class="n">input_quantizers</span><span class="p">)</span>
        <span class="n">num_inputs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_tensors</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_tensors</span><span class="p">)</span> <span class="o">!=</span> <span class="n">num_quantizers</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;number of input quantizers: </span><span class="si">%d</span><span class="s2"> available for layer: </span><span class="si">%s</span><span class="s2"> &quot;</span>
                           <span class="s2">&quot;doesn&#39;t match with number of input tensors: </span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">num_quantizers</span><span class="p">,</span> <span class="n">layer_name</span><span class="p">,</span> <span class="n">num_inputs</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="p">(</span><span class="n">input_tensor</span><span class="p">,</span> <span class="n">quantizer</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">input_tensors</span><span class="p">,</span> <span class="n">layer</span><span class="o">.</span><span class="n">input_quantizers</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">quantizer</span><span class="o">.</span><span class="n">enabled</span><span class="p">:</span>
                <span class="n">quantizer_encoding</span> <span class="o">=</span> <span class="n">_get_encoding_by_quantizer</span><span class="p">(</span><span class="n">quantizer</span><span class="p">)</span>
                <span class="n">encoding</span> <span class="o">=</span> <span class="n">QuantizationSimModel</span><span class="o">.</span><span class="n">_create_encoding_dict</span><span class="p">(</span><span class="n">quantizer_encoding</span><span class="p">,</span>
                                                                      <span class="n">quantizer</span><span class="p">,</span>
                                                                      <span class="n">propagate_encodings</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">activation_encodings_onnx</span><span class="p">[</span><span class="n">input_tensor</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">encoding</span><span class="p">]</span>
                <span class="c1"># Check if layer exists in the pytorch encoding dictionary</span>
                <span class="k">if</span> <span class="n">layer_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">activation_encodings_torch</span><span class="p">:</span>
                    <span class="n">activation_encodings_torch</span><span class="p">[</span><span class="n">layer_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">if</span> <span class="n">QUANTIZER_TYPE_INPUT</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">activation_encodings_torch</span><span class="p">[</span><span class="n">layer_name</span><span class="p">]:</span>
                    <span class="n">activation_encodings_torch</span><span class="p">[</span><span class="n">layer_name</span><span class="p">][</span><span class="n">QUANTIZER_TYPE_INPUT</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="c1"># Store encodings for a particular index so that they can be used to check if a quantizer was</span>
                <span class="c1"># enabled or not</span>
                <span class="n">activation_encodings_torch</span><span class="p">[</span><span class="n">layer_name</span><span class="p">][</span><span class="n">QUANTIZER_TYPE_INPUT</span><span class="p">][</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">encoding</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_layer_input_tensors</span><span class="p">(</span><span class="n">layer</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">,</span> <span class="n">layer_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">op_to_io_tensor_map</span><span class="p">:</span> <span class="n">Dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function returns the list of input tensor names mapped from a PyTorch Op.</span>

<span class="sd">        :param layer: layer as torch.nn.Module</span>
<span class="sd">        :param layer_name: Name of the PyTorch layer</span>
<span class="sd">        :param op_to_io_tensor_map: ONNX or Torch Script map of layer name to it&#39;s input/output tensors</span>
<span class="sd">        :return: list of input tensor names.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">param_inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">layer_name</span> <span class="o">+</span> <span class="s1">&#39;.&#39;</span> <span class="o">+</span> <span class="n">param_name</span> <span class="k">for</span> <span class="n">param_name</span> <span class="ow">in</span> <span class="n">layer</span><span class="o">.</span><span class="n">param_quantizers</span><span class="p">]</span>
        <span class="n">start_op_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">key</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">op_to_io_tensor_map</span>
                          <span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">layer_name</span><span class="p">)</span> <span class="ow">and</span> <span class="s1">&#39;#0&#39;</span> <span class="ow">in</span> <span class="n">key</span><span class="p">)</span> <span class="ow">or</span> <span class="n">key</span> <span class="o">==</span> <span class="n">layer_name</span><span class="p">]</span>

        <span class="n">input_tensors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">start_op_names</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">input_tensor</span> <span class="ow">in</span> <span class="n">op_to_io_tensor_map</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">inputs</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">input_tensor</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">param_inputs</span><span class="p">:</span>
                    <span class="n">input_tensors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">input_tensor</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">input_tensors</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_get_layer_activation_tensors</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">layer_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">op_to_io_tensor_map</span><span class="p">:</span> <span class="n">Dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function returns the list of output tensor and intermediate tensor names mapped from a PyTorch Op.</span>

<span class="sd">        :param layer_name: Name of the PyTorch layer</span>
<span class="sd">        :param op_to_io_tensor_map: ONNX or Torch Script map of layer name to it&#39;s input/output tensors</span>
<span class="sd">        :return: tuple containing list of output tensor names and list of intermediate tensors</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">end_op_names</span><span class="p">,</span> <span class="n">op_names</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">find_op_names_for_layer</span><span class="p">(</span><span class="n">layer_name</span><span class="p">,</span> <span class="n">op_to_io_tensor_map</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">end_op_names</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">output_op_map_str</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_get_output_map_str</span><span class="p">(</span><span class="n">end_op_names</span><span class="p">,</span> <span class="n">layer_name</span><span class="p">,</span> <span class="n">op_to_io_tensor_map</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;layer_name: </span><span class="si">%s</span><span class="s2">, has multiple output onnx ops: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">layer_name</span><span class="p">,</span> <span class="n">output_op_map_str</span><span class="p">)</span>

        <span class="n">output_tensors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">intermediate_tensors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">op_names</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">end_op_names</span><span class="p">:</span>
                <span class="n">output_tensors</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">op_to_io_tensor_map</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">outputs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">intermediate_tensors</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">op_to_io_tensor_map</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">outputs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">output_tensors</span><span class="p">,</span> <span class="n">intermediate_tensors</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_output_map_str</span><span class="p">(</span><span class="n">end_op_names</span><span class="p">,</span> <span class="n">layer_name</span><span class="p">,</span> <span class="n">op_to_io_tensor_map</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function returns formatted list of output ops tensor mapping</span>

<span class="sd">        :param end_op_names: list of output onnx ops</span>
<span class="sd">        :param layer_name: Name of the PyTorch layer</span>
<span class="sd">        :param op_to_io_tensor_map: ONNX or Torch Script map of layer name to it&#39;s input/output tensors</span>
<span class="sd">        :return: formatted string with output ops and their corresponding output count.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">num_output_ops</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">end_op_names</span><span class="p">)</span>
        <span class="n">op_map_str</span> <span class="o">=</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">layer_name</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;&quot;</span><span class="p">)</span><span class="si">}</span><span class="s1">:</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">op_to_io_tensor_map</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">outputs</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span>
                               <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">end_op_names</span><span class="p">[:</span><span class="mi">5</span><span class="p">]])</span>
        <span class="k">if</span> <span class="n">num_output_ops</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">:</span>
            <span class="n">op_map_str</span> <span class="o">+=</span> <span class="s1">&#39;, ..&#39;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">num_output_ops</span><span class="si">}</span><span class="s1">,[</span><span class="si">{</span><span class="n">op_map_str</span><span class="si">}</span><span class="s1">]&#39;</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_update_encoding_dict_for_recurrent_layers</span><span class="p">(</span><span class="n">layer</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">,</span> <span class="n">layer_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">op_to_io_tensor_map</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span>
                                                   <span class="n">activation_encodings_onnx</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">param_encodings</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span>
                                                   <span class="n">propagate_encodings</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :param layer:</span>
<span class="sd">        :param layer_name:</span>
<span class="sd">        :param op_to_io_tensor_map:</span>
<span class="sd">        :param activation_encodings_onnx:</span>
<span class="sd">        :param param_encodings:</span>
<span class="sd">        :param propagate_encodings:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># pylint: disable=too-many-nested-blocks</span>
        <span class="c1"># pylint: disable=too-many-locals</span>

        <span class="n">onnx_activations_to_quantizers</span><span class="p">,</span> <span class="n">onnx_params_to_quantizers</span> <span class="o">=</span> \
            <span class="n">layer</span><span class="o">.</span><span class="n">get_activation_param_quantizers_for_onnx_tensors</span><span class="p">(</span><span class="n">op_to_io_tensor_map</span><span class="p">[</span><span class="n">layer_name</span> <span class="o">+</span>
                                                                                       <span class="s1">&#39;#root_node&#39;</span><span class="p">])</span>
        <span class="c1"># ------------------</span>
        <span class="c1"># Activations</span>
        <span class="c1"># ------------------</span>
        <span class="n">quantizer</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">tensor</span><span class="p">,</span> <span class="n">quantizer</span> <span class="ow">in</span> <span class="n">onnx_activations_to_quantizers</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">quantizer_encoding</span> <span class="o">=</span> <span class="n">_get_encoding_by_quantizer</span><span class="p">(</span><span class="n">quantizer</span><span class="p">)</span>
            <span class="n">encoding</span> <span class="o">=</span> <span class="n">QuantizationSimModel</span><span class="o">.</span><span class="n">_create_encoding_dict</span><span class="p">(</span><span class="n">quantizer_encoding</span><span class="p">,</span> <span class="n">quantizer</span><span class="p">,</span>
                                                                  <span class="n">propagate_encodings</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">activation_encodings_onnx</span><span class="p">[</span><span class="n">tensor</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">encoding</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">propagate_encodings</span> <span class="ow">and</span> <span class="n">quantizer</span><span class="p">:</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">op_names</span> <span class="o">=</span> <span class="n">QuantizationSimModel</span><span class="o">.</span><span class="n">find_op_names_for_layer</span><span class="p">(</span><span class="n">layer_name</span><span class="p">,</span> <span class="n">op_to_io_tensor_map</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">op_name</span> <span class="ow">in</span> <span class="n">op_names</span><span class="p">:</span>
                <span class="n">io_tensor_list</span> <span class="o">=</span> <span class="n">op_to_io_tensor_map</span><span class="p">[</span><span class="n">op_name</span><span class="p">]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">io_tensor_list</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="n">io_tensor_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">io_tensor_list</span><span class="p">]</span>

                <span class="k">for</span> <span class="n">io_tensors</span> <span class="ow">in</span> <span class="n">io_tensor_list</span><span class="p">:</span>

                    <span class="k">if</span> <span class="n">io_tensors</span><span class="o">.</span><span class="n">outputs</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">output_tensor</span> <span class="ow">in</span> <span class="n">io_tensors</span><span class="o">.</span><span class="n">outputs</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">output_tensor</span> <span class="ow">in</span> <span class="n">onnx_activations_to_quantizers</span><span class="p">:</span>
                                <span class="k">continue</span>
                            <span class="n">quantizer_encoding</span> <span class="o">=</span> <span class="n">_get_encoding_by_quantizer</span><span class="p">(</span><span class="n">quantizer</span><span class="p">)</span>
                            <span class="n">encoding</span> <span class="o">=</span> <span class="n">QuantizationSimModel</span><span class="o">.</span><span class="n">_create_encoding_dict</span><span class="p">(</span><span class="n">quantizer_encoding</span><span class="p">,</span> <span class="n">quantizer</span><span class="p">,</span>
                                                                                  <span class="kc">True</span><span class="p">)</span>

                            <span class="n">activation_encodings_onnx</span><span class="p">[</span><span class="n">output_tensor</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">encoding</span><span class="p">]</span>

        <span class="c1"># ------------------</span>
        <span class="c1"># Params</span>
        <span class="c1"># ------------------</span>
        <span class="k">for</span> <span class="n">tensor</span><span class="p">,</span> <span class="n">quantizer</span> <span class="ow">in</span> <span class="n">onnx_params_to_quantizers</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">quantizer_encoding</span> <span class="o">=</span> <span class="n">_get_encoding_by_quantizer</span><span class="p">(</span><span class="n">quantizer</span><span class="p">)</span>
            <span class="n">encoding</span> <span class="o">=</span> <span class="n">QuantizationSimModel</span><span class="o">.</span><span class="n">_create_encoding_dict</span><span class="p">(</span><span class="n">quantizer_encoding</span><span class="p">,</span> <span class="n">quantizer</span><span class="p">,</span>
                                                                  <span class="n">propagate_encodings</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">param_encodings</span><span class="p">[</span><span class="n">tensor</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">encoding</span><span class="p">]</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_qc_quantized_layers</span><span class="p">(</span><span class="n">model</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">QcQuantizeWrapper</span><span class="p">]]:</span>
        <span class="n">quantized_layers</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">module</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">named_modules</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="p">(</span><span class="n">QcQuantizeWrapper</span><span class="p">,</span> <span class="n">QcQuantizeRecurrent</span><span class="p">)):</span>
                <span class="n">quantized_layers</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">name</span><span class="p">,</span> <span class="n">module</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">quantized_layers</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_is_quantizable_module</span><span class="p">(</span><span class="n">module_ref</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Function to check if a module is eligible for quantization.</span>
<span class="sd">            If the module is NOT an PyTorch module type or if the module was already</span>
<span class="sd">            Quantized or if the module is in the layers_to_ignore list, don&#39;t quantize.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">module_ref</span><span class="p">,</span> <span class="n">unquantizable_modules</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Module </span><span class="si">%s</span><span class="s2"> not quantizable&quot;</span><span class="p">,</span> <span class="n">module_ref</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Module </span><span class="si">%s</span><span class="s2"> is quantizable&quot;</span><span class="p">,</span> <span class="n">module_ref</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_create_quantizer_module</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">module_to_quantize</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">,</span> <span class="n">num_inout_tensors</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span>
                                 <span class="n">data_type</span><span class="p">:</span> <span class="n">QuantizationDataType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Instantiates wrapper based on quant scheme</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quant_scheme</span> <span class="ow">in</span> <span class="p">[</span><span class="n">QuantScheme</span><span class="o">.</span><span class="n">post_training_tf</span><span class="p">,</span> <span class="n">QuantScheme</span><span class="o">.</span><span class="n">post_training_tf_enhanced</span><span class="p">,</span>
                                      <span class="n">QuantScheme</span><span class="o">.</span><span class="n">training_range_learning_with_tf_enhanced_init</span><span class="p">,</span>
                                      <span class="n">QuantScheme</span><span class="o">.</span><span class="n">training_range_learning_with_tf_init</span><span class="p">,</span>
                                      <span class="n">QuantScheme</span><span class="o">.</span><span class="n">post_training_percentile</span><span class="p">]</span>

        <span class="c1"># We lookup the number of input and output tensors already determined</span>
        <span class="c1"># Special case, we are adding a wrapper for a module not in the forward pass: Use default of 1, 1</span>
        <span class="n">num_in_tensors</span><span class="p">,</span> <span class="n">num_out_tensors</span> <span class="o">=</span> <span class="n">num_inout_tensors</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">module_to_quantize</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="c1"># Set quantizer to be a module replacer if it is in qc_quantize_modules_dict, otherwise set as</span>
        <span class="c1"># StaticGridQuantWrapper.</span>
        <span class="n">quantizer_wrapper_type</span> <span class="o">=</span> <span class="n">qc_quantize_modules_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">module_to_quantize</span><span class="p">),</span> <span class="n">StaticGridQuantWrapper</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quant_scheme</span> <span class="ow">in</span> <span class="p">[</span><span class="n">QuantScheme</span><span class="o">.</span><span class="n">post_training_tf</span><span class="p">,</span> <span class="n">QuantScheme</span><span class="o">.</span><span class="n">post_training_tf_enhanced</span><span class="p">,</span>
                                  <span class="n">QuantScheme</span><span class="o">.</span><span class="n">post_training_percentile</span><span class="p">]:</span>
            <span class="n">quant_scheme_for_initialization</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quant_scheme</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quant_scheme</span> <span class="o">==</span> <span class="n">QuantScheme</span><span class="o">.</span><span class="n">training_range_learning_with_tf_init</span><span class="p">:</span>
            <span class="n">quant_scheme_for_initialization</span> <span class="o">=</span> <span class="n">QuantScheme</span><span class="o">.</span><span class="n">post_training_tf</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quant_scheme</span> <span class="o">==</span> <span class="n">QuantScheme</span><span class="o">.</span><span class="n">training_range_learning_with_tf_enhanced_init</span><span class="p">:</span>
            <span class="n">quant_scheme_for_initialization</span> <span class="o">=</span> <span class="n">QuantScheme</span><span class="o">.</span><span class="n">post_training_tf_enhanced</span>

        <span class="c1"># TODO add quant_scheme_for_initialization for FP8 case</span>
        <span class="n">quantized_module</span> <span class="o">=</span> <span class="n">quantizer_wrapper_type</span><span class="p">(</span><span class="n">module_to_quantize</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default_param_bw</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default_output_bw</span><span class="p">,</span>
                                                  <span class="bp">self</span><span class="o">.</span><span class="n">_rounding_mode</span><span class="p">,</span> <span class="n">quant_scheme_for_initialization</span><span class="p">,</span> <span class="n">num_inputs</span><span class="o">=</span><span class="n">num_in_tensors</span><span class="p">,</span>
                                                  <span class="n">num_outputs</span><span class="o">=</span><span class="n">num_out_tensors</span><span class="p">,</span> <span class="n">data_type</span><span class="o">=</span><span class="n">data_type</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">quantized_module</span>

    <span class="k">def</span> <span class="nf">_add_quantization_wrappers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">module</span><span class="p">,</span> <span class="n">num_inout_tensors</span><span class="p">,</span> <span class="n">default_data_type</span><span class="p">:</span> <span class="n">QuantizationDataType</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Recursively add quantization wrappers to all appropriate modules starting with module</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">module_name</span><span class="p">,</span> <span class="n">module_ref</span> <span class="ow">in</span> <span class="n">module</span><span class="o">.</span><span class="n">named_children</span><span class="p">():</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;nn.Module found : </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">module_ref</span><span class="p">)</span>

            <span class="c1"># check if the module already quantized then ignore</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_quantizable_module</span><span class="p">(</span><span class="n">module_ref</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="c1"># check if the module is leaf or not</span>
            <span class="k">if</span> <span class="n">utils</span><span class="o">.</span><span class="n">is_leaf_module</span><span class="p">(</span><span class="n">module_ref</span><span class="p">):</span>

                <span class="c1"># Create a new QcQuantize wrapper module</span>
                <span class="n">quantized_module</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_quantizer_module</span><span class="p">(</span><span class="n">module_ref</span><span class="p">,</span> <span class="n">num_inout_tensors</span><span class="p">,</span> <span class="n">default_data_type</span><span class="p">)</span>

                <span class="nb">setattr</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">module_name</span><span class="p">,</span> <span class="n">quantized_module</span><span class="p">)</span>

            <span class="c1"># recursively call children modules</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_add_quantization_wrappers</span><span class="p">(</span><span class="n">module_ref</span><span class="p">,</span> <span class="n">num_inout_tensors</span><span class="p">,</span> <span class="n">default_data_type</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_create_encoding_dict</span><span class="p">(</span><span class="n">encoding</span><span class="p">:</span> <span class="n">libpymo</span><span class="o">.</span><span class="n">TfEncoding</span><span class="p">,</span> <span class="n">quantizer</span><span class="p">,</span> <span class="n">propagate_encodings</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Dict</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create encoding dictionary from encoding object</span>
<span class="sd">        :param encoding: Encoding of the quantizer</span>
<span class="sd">        :param quantizer: Tensor Quantizer</span>
<span class="sd">        :param propagate_encodings: If True, encoding entries for intermediate ops (when one PyTorch ops results in</span>
<span class="sd">                multiple ONNX nodes) are filled with the same BW and data_type as the output tensor for that series of</span>
<span class="sd">                ops.</span>
<span class="sd">        :return: Encoding Dictionary</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data_type</span><span class="p">,</span> <span class="n">bitwidth</span> <span class="o">=</span> <span class="n">quantizer</span><span class="o">.</span><span class="n">data_type</span><span class="p">,</span> <span class="n">quantizer</span><span class="o">.</span><span class="n">bitwidth</span>

        <span class="k">if</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">QuantizationDataType</span><span class="o">.</span><span class="n">float</span><span class="p">:</span>
            <span class="n">enc_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;bitwidth&#39;</span><span class="p">:</span> <span class="n">bitwidth</span><span class="p">,</span> <span class="s1">&#39;dtype&#39;</span><span class="p">:</span> <span class="s2">&quot;float&quot;</span><span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">encoding</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">propagate_encodings</span><span class="p">:</span>
                    <span class="c1"># Shortened encodings will be filled into a layer that only exists due to expansion of PyTorch ops</span>
                    <span class="c1"># into multiple ONNX ops so that it&#39;s necessarily to use the same bitwidth and type</span>
                    <span class="n">enc_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;bitwidth&#39;</span><span class="p">:</span> <span class="n">encoding</span><span class="o">.</span><span class="n">bw</span><span class="p">,</span> <span class="s1">&#39;dtype&#39;</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">}</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">encoding_min</span><span class="p">,</span> <span class="n">encoding_max</span><span class="p">,</span> <span class="n">bw</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">encoding</span><span class="o">.</span><span class="n">min</span><span class="p">,</span> <span class="n">encoding</span><span class="o">.</span><span class="n">max</span><span class="p">,</span> <span class="n">encoding</span><span class="o">.</span><span class="n">bw</span><span class="p">,</span> \
                                                                    <span class="n">encoding</span><span class="o">.</span><span class="n">delta</span><span class="p">,</span> <span class="n">encoding</span><span class="o">.</span><span class="n">offset</span>
                    <span class="n">is_symmetric</span> <span class="o">=</span> <span class="n">quantizer</span><span class="o">.</span><span class="n">use_symmetric_encodings</span>

                    <span class="n">enc_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;min&#39;</span><span class="p">:</span> <span class="n">encoding_min</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span><span class="p">:</span> <span class="n">encoding_max</span><span class="p">,</span> <span class="s1">&#39;scale&#39;</span><span class="p">:</span> <span class="n">scale</span><span class="p">,</span> <span class="s1">&#39;offset&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">offset</span><span class="p">),</span>
                                <span class="s1">&#39;bitwidth&#39;</span><span class="p">:</span> <span class="n">bw</span><span class="p">,</span> <span class="s1">&#39;is_symmetric&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">is_symmetric</span><span class="p">),</span> <span class="s1">&#39;dtype&#39;</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">enc_dict</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">enc_dict</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_remove_quantization_wrappers</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">starting_module</span><span class="p">,</span> <span class="n">list_of_modules_to_exclude</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Recursively remove quantization wrappers from all appropriate modules starting with a given module</span>
<span class="sd">        :param starting_module: Module to recursive search downstream from</span>
<span class="sd">        :param list_of_modules_to_exclude: List of torch modules to remove quantization wrappers from (if present)</span>
<span class="sd">        :return: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">module_name</span><span class="p">,</span> <span class="n">module_ref</span> <span class="ow">in</span> <span class="n">starting_module</span><span class="o">.</span><span class="n">named_children</span><span class="p">():</span>

            <span class="c1"># If modules is in the exclude list, remove the wrapper</span>
            <span class="k">if</span> <span class="n">module_ref</span> <span class="ow">in</span> <span class="n">list_of_modules_to_exclude</span><span class="p">:</span>

                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">module_ref</span><span class="p">,</span> <span class="n">QcQuantizeWrapper</span><span class="p">):</span>
                    <span class="c1"># Remove the wrapper, gets auto-deleted</span>
                    <span class="c1"># pylint: disable=protected-access</span>
                    <span class="nb">setattr</span><span class="p">(</span><span class="n">starting_module</span><span class="p">,</span> <span class="n">module_name</span><span class="p">,</span> <span class="n">module_ref</span><span class="o">.</span><span class="n">_module_to_wrap</span><span class="p">)</span>

                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">module_ref</span><span class="p">,</span> <span class="n">QcQuantizeStandAloneBase</span><span class="p">):</span>
                    <span class="nb">setattr</span><span class="p">(</span><span class="n">starting_module</span><span class="p">,</span> <span class="n">module_name</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Identity</span><span class="p">())</span>

                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">module_ref</span><span class="p">,</span> <span class="n">QcQuantizeRecurrent</span><span class="p">):</span>
                    <span class="n">module_ref</span><span class="o">.</span><span class="n">update_params</span><span class="p">()</span>
                    <span class="nb">setattr</span><span class="p">(</span><span class="n">starting_module</span><span class="p">,</span> <span class="n">module_name</span><span class="p">,</span> <span class="n">module_ref</span><span class="o">.</span><span class="n">module_to_quantize</span><span class="p">)</span>

            <span class="c1"># Recursively call children modules if present</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">utils</span><span class="o">.</span><span class="n">is_leaf_module</span><span class="p">(</span><span class="n">module_ref</span><span class="p">):</span>
                <span class="bp">cls</span><span class="o">.</span><span class="n">_remove_quantization_wrappers</span><span class="p">(</span><span class="n">module_ref</span><span class="p">,</span> <span class="n">list_of_modules_to_exclude</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_add_inputs_hook</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hooks</span><span class="p">):</span>
        <span class="n">module_to_name_map</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">module</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">named_modules</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">QcQuantizeWrapper</span><span class="p">):</span>
                <span class="c1"># pylint: disable=protected-access</span>
                <span class="n">module_to_name_map</span><span class="p">[</span><span class="n">module</span><span class="o">.</span><span class="n">_module_to_wrap</span><span class="p">]</span> <span class="o">=</span> <span class="n">name</span>

        <span class="c1"># Add any leaf modules that are not wrapped by QcQuantizeWrapper (like Identity)</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">module</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">named_modules</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">utils</span><span class="o">.</span><span class="n">is_leaf_module</span><span class="p">(</span><span class="n">module</span><span class="p">)</span> <span class="ow">and</span> <span class="n">module</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">module_to_name_map</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">module_to_name_map</span><span class="p">[</span><span class="n">module</span><span class="p">]</span> <span class="o">=</span> <span class="n">name</span>

        <span class="k">def</span> <span class="nf">inputs_hook</span><span class="p">(</span><span class="n">module_ref</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">_</span><span class="p">):</span>
            <span class="c1"># Need to remove hook here, otherwise the jit trace of CustomMarker with module ref will error since the</span>
            <span class="c1"># hook will be recursively hit.</span>
            <span class="n">hooks</span><span class="p">[</span><span class="n">module_ref</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>
            <span class="k">del</span> <span class="n">hooks</span><span class="p">[</span><span class="n">module_ref</span><span class="p">]</span>
            <span class="n">module_name</span> <span class="o">=</span> <span class="n">module_to_name_map</span><span class="p">[</span><span class="n">module_ref</span><span class="p">]</span>
            <span class="n">marker_layer</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">jit</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">CustomMarker</span><span class="p">(</span><span class="n">module_ref</span><span class="p">,</span> <span class="n">module_name</span><span class="p">,</span> <span class="s1">&#39;True&#39;</span><span class="p">),</span>
                                           <span class="n">inputs</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_module_marker_map</span><span class="p">[</span><span class="n">module_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">marker_layer</span>

        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">module</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">named_modules</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_module_marker_map</span> <span class="ow">and</span> <span class="n">utils</span><span class="o">.</span><span class="n">is_leaf_module</span><span class="p">(</span><span class="n">module</span><span class="p">):</span>
                <span class="n">hooks</span><span class="p">[</span><span class="n">module</span><span class="p">]</span> <span class="o">=</span> <span class="n">module</span><span class="o">.</span><span class="n">register_forward_hook</span><span class="p">(</span><span class="n">inputs_hook</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_validate_module_marker_map</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check to make sure all leaf modules have traced Custom Markers associated with them.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">all_leaf_modules</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">missing_inputs_entries</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">module</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">named_modules</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">QcQuantizeWrapper</span><span class="p">):</span>
                <span class="n">all_leaf_modules</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

        <span class="c1"># Add any modules that are not wrapped by QcQuantizeWrappers (like Identity)</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">module</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">named_modules</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">utils</span><span class="o">.</span><span class="n">is_leaf_module</span><span class="p">(</span><span class="n">module</span><span class="p">)</span> <span class="ow">and</span> <span class="s1">&#39;_module_to_wrap&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">name</span><span class="p">:</span>
                <span class="n">all_leaf_modules</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">leaf_module</span> <span class="ow">in</span> <span class="n">all_leaf_modules</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">leaf_module</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_module_marker_map</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">missing_inputs_entries</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">leaf_module</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">missing_inputs_entries</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;In order to export a conditional model, all leaf modules need to be run with some input so &#39;</span>
                        <span class="s1">&#39;torch trace can be done.&#39;</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;The following modules were not run during compute encodings:&#39;</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">missing_inputs_entries</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Please use the sim.run_modules_for_traced_custom_marker(&lt;module list&gt;, dummy_input) api to &#39;</span>
                        <span class="s1">&#39;pass dummy inputs to these modules.&#39;</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Modules which can take the same dummy input can be &#39;</span>
                        <span class="s1">&#39;grouped as a list. For groups of modules with different input shapes, please call &#39;</span>
                        <span class="s1">&#39;sim.run_modules_for_traced_custom_markers() for each group.&#39;</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Exiting quantsim export early.&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_export_conditional</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">filename_prefix</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">dummy_input</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">],</span>
                            <span class="n">forward_pass_callback</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">forward_pass_callback_args</span><span class="p">,</span>
                            <span class="n">onnx_export_args</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">OnnxExportApiArgs</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="n">OnnxExportApiArgs</span><span class="p">(),</span>
                            <span class="n">propagate_encodings</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Export function for conditional models. Performs another round of forward passes to create and store traced</span>
<span class="sd">        CustomMarker info for each leaf module to be later used when scripting the model for export.</span>
<span class="sd">        :param path: path where to store model pth and encodings</span>
<span class="sd">        :param filename_prefix: Prefix to use for filenames of the model pth and encodings files</span>
<span class="sd">        :param dummy_input: Dummy input to the model. Used to parse model graph. It is required for the dummy_input to</span>
<span class="sd">                be placed on CPU.</span>
<span class="sd">        :param forward_pass_callback: A callback function that simply runs forward passes on the model. This callback</span>
<span class="sd">            function should use representative data for the forward pass, so the calculated encodings work for all</span>
<span class="sd">            data samples. This callback internally chooses the number of data samples it wants to use for calculating</span>
<span class="sd">            encodings. The callback should exercise all paths of the conditional model.</span>
<span class="sd">        :param forward_pass_callback_args: These argument(s) are passed to the forward_pass_callback as-is. Up to</span>
<span class="sd">            the user to determine the type of this parameter. E.g. could be simply an integer representing the number</span>
<span class="sd">            of data samples to use. Or could be a tuple of parameters or an object representing something more complex.</span>
<span class="sd">            If set to None, forward_pass_callback will be invoked with no parameters.</span>
<span class="sd">        :param onnx_export_args: onnx specific export arguments</span>
<span class="sd">        :param propagate_encodings: If True, encoding entries for intermediate ops (when one PyTorch ops results in</span>
<span class="sd">                multiple ONNX nodes) are filled with the same BW and data_type as the output tensor for that series of</span>
<span class="sd">                ops.</span>
<span class="sd">        :return: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_conditional</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">onnx_export_args</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">onnx_export_args</span> <span class="o">=</span> <span class="n">OnnxExportApiArgs</span><span class="p">()</span>

        <span class="c1"># If model is conditional, we need to create traced CustomMarkers to be used later during export. Create hooks</span>
        <span class="c1"># here for creating a traced CustomMarker for each leaf module during the forward pass callback.</span>
        <span class="n">hooks</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_conditional</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_add_inputs_hook</span><span class="p">(</span><span class="n">hooks</span><span class="p">)</span>

        <span class="k">with</span> <span class="n">utils</span><span class="o">.</span><span class="n">in_eval_mode</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">),</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
            <span class="n">_</span> <span class="o">=</span> <span class="n">forward_pass_callback</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="n">forward_pass_callback_args</span><span class="p">)</span>

        <span class="c1"># Any hooks that were hit during forward pass callback would have removed themselves. Remove the remaining</span>
        <span class="c1"># hooks that were not run.</span>
        <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">hooks</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">h</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>

        <span class="c1"># Check that all paths were exercised</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate_module_marker_map</span><span class="p">():</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">export</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">filename_prefix</span><span class="p">,</span> <span class="n">dummy_input</span><span class="p">,</span> <span class="n">onnx_export_args</span><span class="p">,</span> <span class="n">propagate_encodings</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">configure_quantization_ops</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">config_file</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">default_output_bw</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">default_param_bw</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                                   <span class="n">default_data_type</span><span class="p">:</span> <span class="n">QuantizationDataType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">QuantSimConfigurator</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Configure inserted quantize ops using config file and fill in all the supported kernels</span>
<span class="sd">        :param config_file: Configuration file to use</span>
<span class="sd">        :param default_output_bw: default bitwidth for activations</span>
<span class="sd">        :param default_param_bw: default bitwidth for params</span>
<span class="sd">        :param default_data_type: default data type</span>
<span class="sd">        :return: QuantSimConfigurator object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">connected_graph</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">error_msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;A connected graph failed to be built.</span><span class="se">\n</span><span class="s1">&#39;</span>
                         <span class="s1">&#39;Unable to proceed with automatically configuring quantization ops using the config file.</span><span class="se">\n</span><span class="s1">&#39;</span>
                         <span class="s1">&#39;Please configure quantization ops manually by redefining &#39;</span>
                         <span class="s1">&#39;QuantizationSimModel.configure_quantization_ops()&#39;</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">error_msg</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="n">error_msg</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">QuantSimConfigurator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">connected_graph</span><span class="p">,</span> <span class="n">config_file</span><span class="p">,</span> <span class="n">default_output_bw</span><span class="p">,</span>
                                    <span class="n">default_param_bw</span><span class="p">,</span> <span class="n">default_data_type</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_and_freeze_param_encodings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">encoding_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set and freeze parameter encodings from encodings JSON file</span>
<span class="sd">        :param encoding_path: path from where to load parameter encodings file</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Load parameter encodings file</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">encoding_path</span><span class="p">)</span> <span class="k">as</span> <span class="n">json_file</span><span class="p">:</span>
            <span class="n">param_encodings</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">json_file</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">quant_module</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">named_modules</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">quant_module</span><span class="p">,</span> <span class="n">QcQuantizeWrapper</span><span class="p">):</span>
                <span class="n">quant_module</span><span class="o">.</span><span class="n">set_param_encoding</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">param_encodings</span><span class="p">)</span>
                <span class="n">quant_module</span><span class="o">.</span><span class="n">freeze_param_encoding</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">param_encodings</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">quant_wrappers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generator for yielding all quantization wrappers and their names</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">module</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">named_modules</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="p">(</span><span class="n">QcQuantizeWrapper</span><span class="p">,</span> <span class="n">QcQuantizeRecurrent</span><span class="p">)):</span>
                <span class="k">yield</span> <span class="n">name</span><span class="p">,</span> <span class="n">module</span>

    <span class="k">def</span> <span class="nf">run_modules_for_traced_custom_marker</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">module_list</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">],</span> <span class="n">dummy_input</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a list of modules to run and dummy input for the module, create a traced CustomMarker for each module</span>
<span class="sd">        and store it in the module_marker map. The same dummy input will be used for all modules.</span>
<span class="sd">        :param module_list: List of modules to create traced CustomMarkers for</span>
<span class="sd">        :param dummy_input: Dummy input for all modules</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">module_to_name_map</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">module</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">named_modules</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">utils</span><span class="o">.</span><span class="n">is_leaf_module</span><span class="p">(</span><span class="n">module</span><span class="p">):</span>
                <span class="k">if</span> <span class="s1">&#39;._module_to_wrap&#39;</span> <span class="ow">in</span> <span class="n">name</span><span class="p">:</span>
                    <span class="n">module_to_name_map</span><span class="p">[</span><span class="n">module</span><span class="p">]</span> <span class="o">=</span> <span class="n">name</span><span class="p">[:</span><span class="n">MODULE_TO_WRAP_STRING_REVERSE_INDEX</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">module_to_name_map</span><span class="p">[</span><span class="n">module</span><span class="p">]</span> <span class="o">=</span> <span class="n">name</span>

        <span class="k">for</span> <span class="n">module</span> <span class="ow">in</span> <span class="n">module_list</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">QcQuantizeWrapper</span><span class="p">):</span>
                <span class="n">module</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="s1">&#39;_module_to_wrap&#39;</span><span class="p">)</span>
            <span class="c1"># Only perform init and trace if the given module is a leaf module, and we have not recorded it before</span>
            <span class="k">if</span> <span class="n">module</span> <span class="ow">in</span> <span class="n">module_to_name_map</span> <span class="ow">and</span> <span class="n">module_to_name_map</span><span class="p">[</span><span class="n">module</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_module_marker_map</span><span class="p">:</span>
                <span class="k">with</span> <span class="n">utils</span><span class="o">.</span><span class="n">in_eval_mode</span><span class="p">(</span><span class="n">module</span><span class="p">),</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
                    <span class="n">marker_layer</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">jit</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">CustomMarker</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">module_to_name_map</span><span class="p">[</span><span class="n">module</span><span class="p">],</span> <span class="s1">&#39;True&#39;</span><span class="p">),</span>
                                                   <span class="n">dummy_input</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_module_marker_map</span><span class="p">[</span><span class="n">module_to_name_map</span><span class="p">[</span><span class="n">module</span><span class="p">]]</span> <span class="o">=</span> <span class="n">marker_layer</span>

    <span class="k">def</span> <span class="nf">_validate_supported_kernels_for_quantizers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">action</span><span class="p">:</span> <span class="n">SupportedKernelsAction</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Validate supported kernels for all the Quantizers in the QuantSimModel</span>
<span class="sd">        :param action: The action to be performed when incorrect candidate is set in a quantizer</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">apply_act_param_rules</span><span class="p">(</span><span class="n">curr_candidate</span><span class="p">:</span> <span class="n">QuantDtypeBwInfo</span><span class="p">,</span> <span class="n">allowed_supported_kernels</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">QuantDtypeBwInfo</span><span class="p">],</span> <span class="n">module_name</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            helper function to validate both activation and param against the supported_kernels passed</span>
<span class="sd">            :param curr_candidate: candidate of interest</span>
<span class="sd">            :param allowed_supported_kernels: List of supported kernels for the given module</span>
<span class="sd">            :param module_name: name of the module</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">action</span> <span class="o">!=</span> <span class="n">SupportedKernelsAction</span><span class="o">.</span><span class="n">allow_error</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">allowed_supported_kernels</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">curr_candidate</span> <span class="o">==</span> <span class="n">k</span><span class="p">:</span>
                        <span class="k">return</span>

                <span class="k">if</span> <span class="n">action</span> <span class="o">==</span> <span class="n">SupportedKernelsAction</span><span class="o">.</span><span class="n">warn_on_error</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;candidate:</span><span class="si">%s</span><span class="s2"> is not under the supported_kernels for the module </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">curr_candidate</span><span class="p">,</span>
                                   <span class="n">module_name</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">action</span> <span class="o">==</span> <span class="n">SupportedKernelsAction</span><span class="o">.</span><span class="n">assert_on_error</span><span class="p">:</span>
                    <span class="n">error_msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;candidate: </span><span class="si">{</span><span class="n">curr_candidate</span><span class="si">}</span><span class="s1"> is not under the supported_kernels for the module </span><span class="si">{</span><span class="n">module_name</span><span class="si">}</span><span class="s1">&#39;</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="n">error_msg</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">apply_act_rules</span><span class="p">(</span><span class="n">act</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">QuantizationDataType</span><span class="p">],</span> <span class="n">allowed_supported_kernels</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">QuantDtypeBwInfo</span><span class="p">],</span> <span class="n">module_name</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            helper function to validate both activation only against the supported_kernels passed</span>
<span class="sd">            :param act: act of the candidate to be validated</span>
<span class="sd">            :param allowed_supported_kernels: List of supported kernels for the given module</span>
<span class="sd">            :param module_name: name of the module</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">action</span> <span class="o">!=</span> <span class="n">SupportedKernelsAction</span><span class="o">.</span><span class="n">allow_error</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">allowed_supported_kernels</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">k</span><span class="o">.</span><span class="n">is_same_activation</span><span class="p">(</span><span class="n">act</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">act</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                        <span class="k">return</span>

                <span class="k">if</span> <span class="n">action</span> <span class="o">==</span> <span class="n">SupportedKernelsAction</span><span class="o">.</span><span class="n">warn_on_error</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;activation:</span><span class="si">%s</span><span class="s2"> is not under the supported_kernels for the module </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">act</span><span class="p">,</span> <span class="n">module_name</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">action</span> <span class="o">==</span> <span class="n">SupportedKernelsAction</span><span class="o">.</span><span class="n">assert_on_error</span><span class="p">:</span>
                    <span class="n">error_msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;activation: </span><span class="si">{</span><span class="n">act</span><span class="si">}</span><span class="s1"> is not under the supported_kernels for the module </span><span class="si">{</span><span class="n">module_name</span><span class="si">}</span><span class="s1">&#39;</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="n">error_msg</span><span class="p">)</span>

        <span class="c1"># retrieve all the act and param quantizer candidates, and validate them against supported_kernels</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">module</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">named_modules</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">QcQuantizeWrapper</span><span class="p">)</span> <span class="ow">and</span> <span class="n">module</span><span class="o">.</span><span class="n">supported_kernels</span><span class="p">:</span>
                <span class="n">supported_kernels</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">supported_kernel</span> <span class="ow">in</span> <span class="n">module</span><span class="o">.</span><span class="n">supported_kernels</span><span class="p">:</span>
                    <span class="c1"># ((activation bitwidth, activation data type), (param bitwidth, param data type))</span>
                    <span class="c1"># TODO modify this once reformat_supported_kernels generates of type QuantDtypeBwInfo</span>
                    <span class="n">supported_kernels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="n">QuantDtypeBwInfo</span><span class="p">(</span><span class="n">supported_kernel</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">supported_kernel</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                                         <span class="n">supported_kernel</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">supported_kernel</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]))</span>

                <span class="n">act_candidates</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">param_candidate</span> <span class="o">=</span> <span class="p">()</span>
                <span class="k">for</span> <span class="n">quantizer</span> <span class="ow">in</span> <span class="n">module</span><span class="o">.</span><span class="n">input_quantizers</span> <span class="o">+</span> <span class="n">module</span><span class="o">.</span><span class="n">output_quantizers</span><span class="p">:</span>
                    <span class="n">act_candidates</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">quantizer</span><span class="o">.</span><span class="n">bitwidth</span><span class="p">,</span> <span class="n">quantizer</span><span class="o">.</span><span class="n">data_type</span><span class="p">))</span>

                <span class="k">if</span> <span class="s1">&#39;weight&#39;</span> <span class="ow">in</span> <span class="n">module</span><span class="o">.</span><span class="n">param_quantizers</span><span class="p">:</span>
                    <span class="n">param_candidate</span> <span class="o">=</span> <span class="p">(</span><span class="n">module</span><span class="o">.</span><span class="n">param_quantizers</span><span class="p">[</span><span class="s1">&#39;weight&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">bitwidth</span><span class="p">,</span>
                                       <span class="n">module</span><span class="o">.</span><span class="n">param_quantizers</span><span class="p">[</span><span class="s1">&#39;weight&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data_type</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">param_candidate</span><span class="p">:</span>
                    <span class="c1"># we need to check weights against all the activations</span>
                    <span class="k">for</span> <span class="n">act_candidate</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">act_candidates</span><span class="p">):</span>
                        <span class="n">apply_act_param_rules</span><span class="p">(</span><span class="n">QuantDtypeBwInfo</span><span class="p">(</span><span class="n">act_candidate</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">act_candidate</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">param_candidate</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                                               <span class="n">param_candidate</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">supported_kernels</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">candidate</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">act_candidates</span><span class="p">):</span>
                        <span class="n">apply_act_rules</span><span class="p">(</span><span class="n">candidate</span><span class="p">,</span> <span class="n">supported_kernels</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">save_checkpoint</span><span class="p">(</span><span class="n">quant_sim_model</span><span class="p">:</span> <span class="n">QuantizationSimModel</span><span class="p">,</span> <span class="n">file_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This API provides a way for the user to save a checkpoint of the quantized model which can</span>
<span class="sd">    be loaded at a later point to continue fine-tuning e.g.</span>
<span class="sd">    See also load_checkpoint()</span>

<span class="sd">    :param quant_sim_model: QuantizationSimModel to save checkpoint for</span>
<span class="sd">    :param file_path: Path to the file where you want to save the checkpoint</span>
<span class="sd">    :return: None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
        <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">quant_sim_model</span><span class="p">,</span> <span class="n">file</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">load_checkpoint</span><span class="p">(</span><span class="n">file_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">QuantizationSimModel</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Load the quantized model</span>

<span class="sd">    :param file_path: Path to the file where you want to save the checkpoint</span>
<span class="sd">    :return: A new instance of the QuantizationSimModel created after loading the checkpoint</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
        <span class="n">sim</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sim</span>


<span class="k">def</span> <span class="nf">check_accumulator_overflow</span><span class="p">(</span><span class="n">model</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">,</span> <span class="n">quant_bw</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">accum_bw</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Checks for any potential for accumulator overflow across all the layers of the given model</span>
<span class="sd">    :param model: Model</span>
<span class="sd">    :param quant_bw: Bitwidth the layers are quantized at</span>
<span class="sd">    :param accum_bw: Bitwidth of the accumulator</span>
<span class="sd">    :return: Name of the layer with the most accumulator range used and range used</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">most_accum_range_used</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">most_accum_range_used_layer</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">for</span> <span class="n">layer_name</span><span class="p">,</span> <span class="n">layer</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">named_modules</span><span class="p">():</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">):</span>
            <span class="n">was_accum_range_exceeded</span><span class="p">,</span> <span class="n">accum_range_used</span> <span class="o">=</span> <span class="n">get_conv_accum_bounds</span><span class="p">(</span><span class="n">layer</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">(),</span>
                                                                               <span class="n">quant_bw</span><span class="p">,</span> <span class="n">accum_bw</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">accum_range_used</span> <span class="o">&gt;</span> <span class="n">most_accum_range_used</span><span class="p">:</span>
                <span class="n">most_accum_range_used</span> <span class="o">=</span> <span class="n">accum_range_used</span>
                <span class="n">most_accum_range_used_layer</span> <span class="o">=</span> <span class="n">layer_name</span>

            <span class="k">if</span> <span class="n">was_accum_range_exceeded</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Possible accumulator overflow for layer: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">layer_name</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">most_accum_range_used</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;No overflow detected. Layer </span><span class="si">%s</span><span class="s1"> had the most accumulator range used: </span><span class="si">%f%%</span><span class="s1">&#39;</span><span class="p">,</span>
                    <span class="n">most_accum_range_used_layer</span><span class="p">,</span> <span class="n">most_accum_range_used</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Overflow detected. Layer </span><span class="si">%s</span><span class="s1"> had the most accumulator range used: </span><span class="si">%f%%</span><span class="s1">&#39;</span><span class="p">,</span>
                    <span class="n">most_accum_range_used_layer</span><span class="p">,</span> <span class="n">most_accum_range_used</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">most_accum_range_used_layer</span><span class="p">,</span> <span class="n">most_accum_range_used</span>


<span class="k">def</span> <span class="nf">load_encodings_to_sim</span><span class="p">(</span><span class="n">quant_sim_model</span><span class="p">:</span> <span class="n">QuantizationSimModel</span><span class="p">,</span> <span class="n">pytorch_encoding_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Loads the saved encodings to quant sim model. The encoding filename to load should end in _torch.encodings,</span>
<span class="sd">    generated as part of quantsim export.</span>

<span class="sd">    :param quant_sim_model: Quantized model to load encodings for. Note: The model configuration should be the same as</span>
<span class="sd">        when encodings were exported.</span>
<span class="sd">    :param pytorch_encoding_path: Path of the encodings file to load.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Load encodings file</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">pytorch_encoding_path</span><span class="p">)</span> <span class="k">as</span> <span class="n">json_file</span><span class="p">:</span>
        <span class="n">encodings</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">json_file</span><span class="p">)</span>

    <span class="c1"># Set param encodings</span>
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">quant_module</span> <span class="ow">in</span> <span class="n">quant_sim_model</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">named_modules</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">quant_module</span><span class="p">,</span> <span class="n">QcQuantizeWrapper</span><span class="p">):</span>
            <span class="n">quant_module</span><span class="o">.</span><span class="n">set_param_encoding</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">encodings</span><span class="p">[</span><span class="s1">&#39;param_encodings&#39;</span><span class="p">])</span>
            <span class="n">quant_module</span><span class="o">.</span><span class="n">set_mode</span><span class="p">(</span><span class="n">QcQuantizeOpMode</span><span class="o">.</span><span class="n">ACTIVE</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">encodings</span><span class="p">[</span><span class="s1">&#39;activation_encodings&#39;</span><span class="p">]:</span>
                <span class="n">quant_module</span><span class="o">.</span><span class="n">set_activation_encoding</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">encodings</span><span class="p">[</span><span class="s1">&#39;activation_encodings&#39;</span><span class="p">])</span>

    <span class="c1"># Certain quantizers may not have encodings loaded in. This can occur for various reasons:</span>
    <span class="c1"># - the quantizer is for a dropout layer</span>
    <span class="c1"># - the quantizer was originally enabled during compute_encodings(), but was not exercised in the forward pass</span>
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">layer</span> <span class="ow">in</span> <span class="n">quant_sim_model</span><span class="o">.</span><span class="n">quant_wrappers</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="n">QcQuantizeWrapper</span><span class="p">):</span>
            <span class="n">input_quantizers</span> <span class="o">=</span> <span class="n">layer</span><span class="o">.</span><span class="n">input_quantizers</span>
            <span class="n">output_quantizers</span> <span class="o">=</span> <span class="n">layer</span><span class="o">.</span><span class="n">output_quantizers</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">input_quantizers</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">layer</span><span class="o">.</span><span class="n">input_quantizers</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
            <span class="n">output_quantizers</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">layer</span><span class="o">.</span><span class="n">output_quantizers</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">quantizer</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">input_quantizers</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">quantizer</span><span class="o">.</span><span class="n">enabled</span> <span class="ow">and</span> <span class="n">quantizer</span><span class="o">.</span><span class="n">encoding</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">quantizer</span><span class="o">.</span><span class="n">enabled</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;No encoding loaded for input quantizer </span><span class="si">%s</span><span class="s1"> of layer </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="p">(</span><span class="n">param_name</span><span class="p">,</span> <span class="n">quantizer</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">layer</span><span class="o">.</span><span class="n">param_quantizers</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="k">if</span> <span class="n">quantizer</span><span class="o">.</span><span class="n">enabled</span> <span class="ow">and</span> <span class="n">quantizer</span><span class="o">.</span><span class="n">encoding</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">quantizer</span><span class="o">.</span><span class="n">enabled</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;No encoding loaded for param quantizer </span><span class="si">%s</span><span class="s1"> of layer </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">param_name</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">quantizer</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">output_quantizers</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">quantizer</span><span class="o">.</span><span class="n">enabled</span> <span class="ow">and</span> <span class="n">quantizer</span><span class="o">.</span><span class="n">encoding</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">quantizer</span><span class="o">.</span><span class="n">enabled</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;No encoding loaded for output quantizer </span><span class="si">%s</span><span class="s1"> of layer </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="n">quant_sim_model</span><span class="o">.</span><span class="n">replace_wrappers_for_quantize_dequantize</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">has_valid_encodings</span><span class="p">(</span><span class="n">qc_quantize_op</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">QcQuantizeWrapper</span><span class="p">,</span> <span class="n">QcQuantizeRecurrent</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Utility for determining whether a given qc_quantize_op has any valid encodings.</span>

<span class="sd">    :param qc_quantize_op: Qc quantize op to evaluate</span>
<span class="sd">    :return: True if any input, param, or output quantizers have valid encodings, False otherwise</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">qc_quantize_op</span><span class="p">,</span> <span class="p">(</span><span class="n">QcQuantizeWrapper</span><span class="p">,</span> <span class="n">QcQuantizeRecurrent</span><span class="p">)):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;has_valid_encodings only supported for QcQuantizeWrapper and QcQuantizeRecurrent &quot;</span>
                     <span class="s2">&quot;modules&quot;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">qc_quantize_op</span><span class="p">,</span> <span class="p">(</span><span class="n">QcQuantizeWrapper</span><span class="p">,</span> <span class="n">QcQuantizeRecurrent</span><span class="p">))</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">qc_quantize_op</span><span class="p">,</span> <span class="n">QcQuantizeWrapper</span><span class="p">):</span>
        <span class="n">input_quantizers</span> <span class="o">=</span> <span class="n">qc_quantize_op</span><span class="o">.</span><span class="n">input_quantizers</span>
        <span class="n">output_quantizers</span> <span class="o">=</span> <span class="n">qc_quantize_op</span><span class="o">.</span><span class="n">output_quantizers</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">input_quantizers</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">qc_quantize_op</span><span class="o">.</span><span class="n">input_quantizers</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="n">output_quantizers</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">qc_quantize_op</span><span class="o">.</span><span class="n">output_quantizers</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

    <span class="k">for</span> <span class="n">quantizer</span> <span class="ow">in</span> <span class="n">input_quantizers</span> <span class="o">+</span> <span class="n">output_quantizers</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">qc_quantize_op</span><span class="o">.</span><span class="n">param_quantizers</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
        <span class="k">if</span> <span class="n">quantizer</span><span class="o">.</span><span class="n">enabled</span> <span class="ow">and</span> <span class="p">(</span><span class="n">quantizer</span><span class="o">.</span><span class="n">encoding</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">quantizer</span><span class="o">.</span><span class="n">data_type</span> <span class="ow">is</span> <span class="n">QuantizationDataType</span><span class="o">.</span><span class="n">float</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>

    <span class="k">return</span> <span class="kc">False</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020, Qualcomm Innovation Center, Inc..</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>